# 💡 트러블슈팅 및 개선 이력

최근 프로젝트 개선 과정에서 발생했던 주요 문제점들과 해결책을 공유합니다. 이러한 내용은 향후 개발 시 유사한 문제를 방지하고, 유지보수성을 높이는 데 기여할 것입니다.

### 1. 메인 페이지 상품 카드 UI/UX 점진적 개선 과정

-   **문제점**: 초기 상품 카드는 모든 상품(단일/복합, 한정/무제한)에 동일한 UI를 제공하여 정보가 부족했고, 공간 활용이 비효율적이었습니다. 또한, 새로운 기능(한정 수량 배너) 추가 시 전체 레이아웃이 어긋나는 문제가 발생했습니다.
-   **개선 과정**: 사용자 피드백을 바탕으로 다음과 같은 단계별 개선을 진행했습니다.
    1.  **정보 추가 및 레이아웃 재구성**:
        -   **문제**: 상품의 보관 타입(냉동/냉장 등)과 특별 라벨(인기/NEW 등)이 표시되지 않아 정보가 부족했습니다.
        -   **해결**: 카드 내부에 **보관 타입 배지**와 **특별 라벨 칩**을 추가했습니다. 더 많은 정보를 담기 위해 카드를 세로로 긴 형태로 변경하고, **`상품명/보관타입`**, **`가격/픽업일`**, **`구매 액션`** 의 명확한 3단 구조로 재배치했습니다.
    2.  **구매 경험 차별화**:
        -   **문제**: 옵션이 없는 단일 상품도 상세 페이지로 이동해야만 구매할 수 있어 비효율적이었습니다.
        -   **해결**: **단일 상품** 카드에는 **수량 조절 버튼과 '담기' 버튼을 바로 노출**시켰고, **복합 상품** 카드에는 **'옵션 선택하기 →' 버튼**을 표시하여 사용자가 명확하게 다음 행동을 인지할 수 있도록 UI를 분리했습니다.
    3.  **한정 수량 강조 및 레이아웃 정렬 문제 해결**:
        -   **문제**: 한정 수량 상품에 대한 시각적 강조가 부족했고, 이를 위해 카드 상단에 조건부 배너를 추가하자 배너가 없는 카드와 높이가 달라져 줄이 어긋나는 문제가 발생했습니다.
        -   **해결**:
            -   '진행 중' 또는 '마감 임박' 상품 중 재고가 한정된 경우, 카드 상단에 **`🔥 NN개 한정!`** 과 같은 강조 배너를 표시하도록 로직을 확장했습니다.
            -   배너 유무에 따라 카드 높이가 달라지는 문제를 해결하기 위해, 상품 목록을 감싸는 컨테이너(`product-grid.horizontal-scroll`)에 **`align-items: flex-end`** CSS 속성을 적용했습니다. 이를 통해 모든 카드가 **아래쪽 라인을 기준으로 정렬**되도록 하여, 높이가 달라도 시각적으로 안정적인 레이아웃을 구현했습니다.
            -   상단 배너와 의미가 중복되는 'LIMITED' 라벨은 카드에 표시되지 않도록 프론트엔드에서 필터링하여 정보를 간결하게 만들었습니다.

### 2. 배너 슬라이더 화살표 위치 문제 해결

-   **문제**: `BannerSlider` 컴포넌트의 네비게이션 화살표가 한쪽에만 쏠려 보이거나 제대로 표시되지 않던 문제. 초기 화면에서 왼쪽 화살표만 나타나는 경우가 있었습니다.
-   **원인**: `BannerSlider.css`에서 화살표 버튼의 `left` 또는 `right` CSS 속성이 명확하게 정의되지 않았거나, 다른 CSS 규칙에 의해 의도치 않게 재정의되었을 가능성이 있었습니다.
-   **해결**: `BannerSlider.css` 파일에서 `.banner-nav-button.prev`와 `.banner-nav-button.next`에 `left`와 `right` 속성을 명확히 지정하고, `auto`로 다른 방향의 속성을 초기화하여 양쪽 화살표가 독립적으로 위치하도록 수정했습니다.

### 3. 상품 목록 수평 스크롤 및 관성 스크롤 개선 (`ProductListPage.tsx`)

-   **문제**: `ProductListPage`에서 상품 목록이 수평으로 원활하게 스크롤되지 않거나, 드래그 후 관성 스크롤이 부자연스럽던 문제. 특정 상황에서 스크롤 화살표가 부적절하게 나타나거나 사라지는 현상이 있었습니다.
-   **원인**: `useHorizontalScroll` 훅 내부의 `setVelocity` 로직이 스크롤 속도를 너무 빠르게 설정하거나, `onMouseUp`, `onMouseLeave`에서 `setVelocity(0)`으로 관성 스크롤을 즉시 멈추도록 설정되어 있었음. 또한, 스크롤 화살표 표시 조건 (`isAtEnd`)이 너무 엄격하여 끝까지 도달해야만 사라지는 문제가 있었습니다.
-   **해결**:
    -   `onMouseMove`에서 `setVelocity` 계산 시 곱하는 값을 `0.5`에서 `0.3`으로 줄여 드래그 후 관성 스크롤 속도를 부드럽게 조정했습니다.
    -   `scrollByPage` 함수에서 스크롤 양을 `container.clientWidth * 0.8`에서 `container.clientWidth * 0.7`으로 줄여 한 번의 클릭 스크롤 이동 거리를 짧게 하여 더 자연스러운 느낌을 주었습니다.
    -   `onMouseUp` 및 `onMouseLeave`에서 `setVelocity(0)` 호출을 제거하여 드래그를 놓았을 때 관성 스크롤이 시작되도록 수정했습니다.
    -   스크롤 화살표 표시 조건 (`isAtEnd`)을 `scrollWidth - 1`에서 `scrollWidth - 5`와 같이 여유 값을 늘려 스크롤 끝 지점을 더 유연하게 감지하도록 개선했습니다.

### 4. `ProductListPage.tsx` 타입스크립트 및 데이터 로딩 로직 개선

-   **문제점**:
    -   `formatPickupDateAndDay` 함수 내 `dayNames.getDay()` 호출 오류: `dayNames`는 문자열 배열인데, `Date` 객체의 메서드인 `getDay()`를 배열에 사용하려 함.
    -   `productQuantities` 객체 접근 오류: `newQuantities.p.id` 또는 `productQuantitiesproduct.id`와 같이 객체 속성 접근 방식이 잘못됨.
    -   `MemoizedProductCard` 컴포넌트 필수 `props` 누락 오류: `onQuantityChange`, `onAddToCart`, `onCardClick` 함수들이 `MemoizedProductCard`로 전달되지 않아 발생.
    -   초기 데이터 로딩 시 Firebase 모듈 동적 import로 인한 잠재적 지연.
-   **원인**: 타입스크립트의 타입 추론 및 객체/배열 문법에 대한 오타 또는 불완전한 이해. Firebase 모듈의 지연 로딩 방식이 초기 로딩 성능에 영향을 미칠 수 있음.
-   **해결**:
    -   타입스크립트 관련 오류 해결: `formatPickupDateAndDay`에서 `dayNames[date.getDay()]`로 수정, `productQuantities[p.id]` 및 `productQuantities[product.id]`와 같이 대괄호(`[]`) 표기법 사용, 누락된 `props` 명시적 전달.
    -   **초기 로딩 시점 개선**: `useEffect` 내부에서 Firebase 모듈 동적 import를 제거하고 파일 상단에 정적으로 import 하여 번들링 최적화 및 런타임 오버헤드 감소.
    -   **상품 필터링 로직 명확화**: `useMemo` 내부의 상품 분류 로직을 더 간결하고 정확하게 수정하여, `status`, `deadlineDate`, `pickupDeadlineDate`, `stock`, `isAvailableForOnsiteSale` 등을 기반으로 `onSiteSaleProducts`, `ongoingProducts`, `additionalReservationProducts`, `pastProducts`로 정확히 분류되도록 개선했습니다.
    -   `MemoizedProductCard` 응집도 향상: 카드 내부에서 `isPurchasable` 등 필요한 모든 상태를 `product` 객체와 `now` 값을 기반으로 자체 판단하도록 변경하여 컴포넌트의 재사용성을 높였습니다.

### 5. `ProductDetailPage.tsx` 상품 상태 및 버튼 표시 로직 최종 개선

-   **문제**:
    -   '판매 중'인 상품인데도 `deadlineDate`가 지났다는 이유만으로 '앵콜 요청' 버튼이 잘못 표시되던 문제 (로그 분석을 통해 확인).
    -   '지난 공동구매' 상품들(마감/품절 상태)에서 앵콜 요청 버튼이 사라지던 문제.
    -   상품의 다양한 판매 상태(판매 중, 판매 예정, 품절, 마감, 추가 예약)에 따라 '장바구니 담기', '앵콜 요청', 또는 '판매 종료' 메시지가 정확하게 표시되지 않는 문제.
-   **원인**: `isCurrentlyPurchasable` 및 `showEncoreRequestButton`을 포함한 판매 가능 여부 판단 로직이 충분히 정교하지 못했거나, 특정 조건들이 상호 배타적이지 않아 의도치 않은 결과 발생. 특히 `deadlineDate`와 `pickupDeadlineDate`를 기준으로 하는 '추가 예약' 시나리오가 명확히 반영되지 않아, `status`가 `selling`이더라도 `deadlineDate`가 지나면 `isCurrentlyPurchasable`이 `false`가 되고 앵콜 버튼이 나타나던 현상 발생.
-   **해결**:
    -   **고객 요구 5가지 시나리오 기반 `isCurrentlyPurchasable` 로직 재정의**:
        -   **1. 공동구매 기간 안에 재고가 있음 (예약 가능)**: `product.status === 'selling'` + `now <= deadlineDate` + (재고 무제한 OR 재고 있음)
        -   **2. 공동구매 기간이 지났지만, 픽업일 전날까지 재고가 있음 (추가 예약 가능)**: `product.status === 'selling'` + `now > deadlineDate` + `now < pickupDeadlineDate` + (재고 있음)
        -   이 두 경우만 `isCurrentlyPurchasable`을 `true`로 설정하여 '장바구니 담기' 버튼이 보이도록 했습니다.
    -   **`showEncoreRequestButton` 조건 강화**: `isCurrentlyPurchasable`이 `false`일 때만 고려하며, `product.status`가 `'sold_out'` 또는 `'ended'`이거나, `deadlineDate`가 지났고 재고가 없거나(선주문 무제한 포함) 하는 등, 앵콜 요청이 합리적인 상황에서만 표시되도록 조건을 조정했습니다. 이를 통해 **마감된 상품에서 앵콜 버튼이 다시 표시**되도록 했습니다.
    -   **하단 버튼 UI 분기 명확화**: `isCurrentlyPurchasable` 여부에 따라 '장바구니 관련 UI'와 '앵콜 요청/판매 종료 메시지 UI'를 명확히 분리하여, 혼동 없이 올바른 버튼이 나타나도록 개선했습니다.
    -   `encoreCount` 업데이트 시 `updatedProductDoc.data()`를 정확히 사용하도록 오타를 수정했습니다.

### 6. `ProductAddAdminPage.tsx` 및 `ProductEditAdminPage.tsx` 상품 등록/수정 UI 및 로직 개선

-   **문제**:
    -   **가격 정책별 한정 수량 기능 부족**: 기존에는 전체 상품에 대한 총 재고만 관리하고 옵션별 재고는 관리되지 않았음.
    -   **UI 깨짐 현상 지속**: '가격 및 재고' 섹션의 입력 필드(특히 '재고갯수' 및 '단위')가 정렬되지 않거나 플레이스홀더 텍스트가 잘리는 문제.
    -   **중복 필드**: '1인당 최대 구매 수량'과 '가격 정책' 내의 '한정수량' 개념이 중복될 가능성.
-   **원인**: 복잡한 폼 요소를 `flexbox`로만 제어하려던 한계, `input` 필드의 `padding` 및 `line-height` 설정 미흡, 논리적 중복 필드 존재.
-   **해결**:
    -   **엑셀 표 형태의 Grid 레이아웃 적용**: '가격 정책' 섹션을 `display: grid`를 사용하여 엑셀 표와 유사한 컬럼 기반의 레이아웃으로 전면 개편했습니다. 이를 통해 '개당(개수)', '가격', '재고갯수', '단위', '한정수량', '제거 버튼'이 명확한 열에 정렬되도록 했습니다.
    -   **옵션별 재고(`stock`) 및 한정수량(`limitQuantity`) 관리 강화**: 각 `pricingOption`에 `stock`과 `limitQuantity` 필드를 추가하여, 옵션별로 재고를 관리하고 필요에 따라 한정 수량을 설정할 수 있도록 했습니다. `stock` 필드를 비워두면 '선예약 후발주' (무제한) 방식으로 처리됩니다.
    -   **'1인당 최대 구매 수량' 섹션 제거**: '가격 정책' 내의 '한정수량'(`limitQuantity`) 필드가 개별 옵션의 수량 제한을 담당하므로, 중복되는 기존의 '1인당 최대 구매 수량' 섹션을 제거하여 UI를 콤팩트하게 만들었습니다.
    -   **UI 요소 정렬 및 가독성 개선**: 각 입력 필드(`input`)의 `padding`, `text-align`, `height` 등을 미세 조정하여 텍스트 및 플레이스홀더가 잘리지 않고 보기 좋게 정렬되도록 했습니다. '재고갯수' 및 '한정수량' 필드의 플레이스홀더 텍스트를 제거하여 깔끔한 디자인을 유지했습니다.
    -   **CSS 최적화**: Grid 시스템 도입으로 복잡한 Flexbox 속성들을 줄이고, CSS 변수(`--spacing-xxs`, `--font-size-sm` 등)를 적극 활용하여 스타일의 일관성과 유지보수성을 높였습니다.

### 7. 관리자 대시보드 로딩 오류 및 데이터 불일치 문제 해결

-   **문제점**: 관리자 페이지의 대시보드 접근 시, 데이터 로딩이 실패하며 앱이 비정상적으로 중단되는 복합적인 오류가 발생했습니다. 콘솔에는 `TypeError`, `key` prop 관련 경고, `500 Internal Server Error` 등 다양한 오류가 동시에 나타났습니다.
-   **원인**: 디버깅을 통해 여러 단계의 원인이 중첩되어 있음을 확인했습니다.
    1.  **컴포넌트의 비정상 종료 (TypeError)**: `DailyDashboardModal` 컴포넌트가 Firestore로부터 데이터를 받지 못했을 경우(예: 색인 부재), `undefined` 상태인 배열 데이터의 `.length` 나 `.toDate()` 속성을 읽으려다 앱이 멈추는 문제였습니다.
    2.  **근본적인 데이터 조회 실패 (FirebaseError)**: Firestore 쿼리에 필요한 복합 색인(composite index)이 없어 `getDailyDashboardData` 함수가 데이터를 전혀 가져오지 못하는 것이 최초의 원인이었습니다.
    3.  **고유 `key` 값 부재 경고**: `getDailyDashboardData` 함수 내부에서 Firestore 문서 데이터를 객체로 변환할 때, 문서의 고유 ID인 `doc.id` 대신 `doc.data().id`를 사용하려 하여 `key` 값이 `undefined`로 할당되던 문제였습니다. 이로 인해 React가 목록 아이템을 제대로 식별하지 못했습니다.
    4.  **개발 서버 오류 (500 Error)**: 수정 과정에서 `useState` 구문에 오타(`= =`)가 포함되어, 개발 서버가 파일을 제대로 해석하지 못하고 `500 Internal Server Error`를 발생시키기도 했습니다.
-   **해결**:
    -   **컴포넌트 안정성 강화**: `DailyDashboardModal` 컴포넌트 내부에서 `useState`의 초기값을 빈 배열(`[]`)로 명확히 하고, `fetch` 후 상태를 업데이트할 때도 `|| []` 연산자를 사용해 항상 배열을 보장하도록 수정했습니다. 또한, 날짜 관련 데이터는 옵셔널 체이닝(`?.toDate()`)을 사용하여 데이터가 `null` 또는 `undefined`일 경우에도 앱이 멈추지 않도록 방어 코드를 추가했습니다.
    -   **Firestore 색인 생성**: 브라우저 콘솔에 출력된 `FirebaseError` 메시지의 링크를 통해 필요한 복합 색인을 생성하여 근본적인 데이터 조회 문제를 해결했습니다.
    -   **데이터 매핑 로직 수정**: `firebase.ts`의 `getDailyDashboardData` 함수에서 `map`, `forEach`를 사용할 때, 고유 ID를 `doc.id`에서 직접 가져오도록 수정하여 모든 리스트 아이템이 명확하고 고유한 `key`를 갖도록 보장했습니다.
    -   **문법 오류 수정**: `500 Error`의 원인이었던 코드 내 오타를 바로잡아 서버가 정상적으로 파일을 제공할 수 있도록 했습니다.

### 8. '판매 회차' 시스템 도입을 통한 상품 관리 아키텍처 재설계

-   **문제점**: 기존에는 동일 상품을 재판매할 때마다 상품 정보를 '복제'하여 새 상품으로 등록했습니다. 이 방식은 '카뮤트 효소' 같은 특정 상품의 누적 판매량, 가격 변동 이력, 고객의 앵콜 요청 횟수 등을 통합적으로 추적하기 어렵게 만들었습니다. 또한, 불필요한 데이터 중복이 발생하여 데이터베이스 관리가 비효율적이었습니다.
-   **원인**: `1 상품 = 1 판매` 라는 단순한 데이터 구조가 반복 판매 시나리오를 제대로 지원하지 못했습니다.
-   **해결**:
    -   **`1 대표 상품 : 多 판매 회차` 데이터 모델 도입**: Firestore의 `Product` 문서 구조를 전면 재설계했습니다. 이제 하나의 `Product` 문서는 이름, 이미지 등 변하지 않는 **고유 정보**와 함께, `salesHistory` 라는 배열 필드에 회차별 판매 정보(가격, 재고, 기간, 옵션 등)를 담은 **`SalesRound` 객체**를 누적하여 저장합니다.
    -   **관리자 UI/UX 개편**:
        -   `ProductListPageAdmin`은 이제 **대표 상품 중심**으로 목록을 보여주며, 각 상품의 최신 회차 상태를 요약하여 표시합니다.
        -   `ProductAddAdminPage`는 **'신규 상품 등록'**과 **'새 회차 추가'**의 두 가지 모드로 동작하도록 개편하여, 관리자가 의도에 맞게 데이터를 추가할 수 있도록 유도합니다.
    -   **기대 효과**: 데이터의 파편화를 막고, 특정 상품의 전체 생명주기를 한눈에 파악할 수 있게 되었습니다. 이를 통해 재고 관리의 정확성을 높이고, 과거 판매 데이터를 기반으로 한 마케팅 전략 수립이 용이해졌습니다. '새 회차 추가' 기능으로 재판매 프로세스가 매우 간소화되었습니다.

### 9. 메인 페이지 UI/UX 및 로직 개선

-   **문제점**: 상품 목록 페이지의 정보 표현이 부족하고, 레이아웃이 비정상적이거나 반복적인 오류가 발생하는 문제가 있었습니다.
-   **해결**:
    -   **상품 분류 로직 개선**: '오늘의 공동구매', '마감 임박! 추가 예약', '지난 공동구매'로 상품을 분류하는 로직이 업데이트되었습니다.

### 10. '섹션 헤더' 반응형 레이아웃 문제 해결 과정

-   **문제점**: 모바일과 같은 좁은 화면에서 섹션 제목(오늘의 공동구매)과 카운트다운 타이머가 한 줄에 표시될 때, 공간 부족으로 인해 제목이 잘리거나 레이아웃이 깨지는 문제가 발생했습니다.
-   **해결 과정**:
    -   처음에는 모바일에서 두 요소를 세로로 쌓는(`flex-direction: column`) 방식을 시도했으나, 디자인의 통일성을 해쳐 폐기했습니다.
    -   카운트다운을 공중에 띄우는(`position: absolute`) 방식도 시도했지만, 다른 요소와의 정렬 문제를 야기했습니다.
    -   **최종 해결책**: 모든 화면에서 한 줄 레이아웃을 유지하되, 모바일 화면에서는 미디어 쿼리를 사용해 제목과 카운트다운 모두의 글자 크기, 여백 등을 줄이는 방식을 채택했습니다. 이를 통해 공간을 확보하여, 잘림이나 줄바꿈 없이 두 요소가 조화롭게 표시되도록 개선했습니다.

### 11. '유령 여백' 디버깅 및 CSS 우선순위(Specificity) 문제 해결

-   **문제점**: 섹션 제목과 상품 카드 목록 사이에 원인을 알 수 없는 수직 여백('유령 여백')이 계속해서 남아, `margin`과 `padding`을 0으로 설정해도 문제가 해결되지 않았습니다.
-   **디버깅 과정**:
    -   브라우저 개발자 도구(F12)를 사용하여 문제의 원인을 추적했습니다.
    -   `border` 디버깅으로 여백의 위치를 특정했고, 요소 검사(Inspect)를 통해 여백이 `h2.section-title` 태그의 기본 `margin` 때문임을 확인했습니다.
    -   하지만 `ProductSection.css`에서 `margin: 0`을 적용해도 스타일이 바뀌지 않는 문제가 지속되었습니다.
-   **진짜 원인 및 해결책**:
    -   **원인**: `common.css` 파일에 정의된 전역 `.section-title` 스타일 규칙이, 컴포넌트별 CSS 파일인 `ProductSection.css`의 규칙보다 우선순위가 높거나 나중에 적용되어 스타일 변경을 덮어쓰고 있었습니다.
    -   **해결**: 특정 컴포넌트에서만 스타일을 억지로 덮어쓰는(`!important` 등`) 대신, 문제의 근원인 `common.css`의 전역 스타일 자체를 반응형으로 수정했습니다. 이를 통해 코드의 일관성을 유지하고, 예측 가능한 방식으로 문제를 해결했습니다. 또한, 이 과정에서 브라우저 캐시로 인해 스타일이 적용되지 않는 현상을 **'강력 새로고침'**으로 해결하는 방법도 확인했습니다.

### 12. 상세 페이지 안정성 및 하위 호환성 최종 개선

-   **문제점**:
    -   '추가 예약' 기간(마감일은 지났지만 픽업일은 도래하지 않은)에 있는 상품이 구매 불가능한 '판매 종료' 상태로 잘못 표시되는 버그가 있었습니다.
    -   과거 데이터 구조(판매 회차 `salesHistory`가 없는)를 가진 상품의 상세 페이지에 접근 시, 재고 확인 과정에서 `TypeError: Cannot read... 'find'` 오류가 발생하며 앱이 비정상적으로 종료되었습니다.
    -   옵션이 여러 개인 상품에서, 데이터베이스에 `id`가 없는 옵션이 포함된 경우 드롭다운 메뉴가 동작하지 않았습니다.

-   **원인**:
    -   **구매 가능 여부 판단 로직 오류**: '추가 예약' 기간을 올바르게 감지하는 조건문이 있었음에도, 최종적으로 구매 가능 상태를 결정하는 로직에 미세한 버그가 있어 '판매 종료'로 잘못 처리되었습니다.
    -   **서버-클라이언트 간 호환성 부재**: 프론트엔드(`ProductDetailPage`)는 구형 데이터를 신형으로 변환하는 로직이 있었지만, 서버 통신 함수(`checkProductAvailability`)는 이러한 변환 로직 없이 신규 데이터 구조(`salesHistory`)만 가정하고 호출되어 오류가 발생했습니다.
    -   **옵션 식별 방식의 한계**: 드롭다운 옵션 변경 로직이 데이터베이스의 `id` 값에만 의존하고 있어, 이 값이 없는 경우 어떤 옵션을 선택했는지 식별할 수 없었습니다.

-   **해결**:
    -   **구매 가능 여부 로직 수정**: 상세 페이지가 마운트될 때, 서버 재확인 전에 클라이언트에 있는 데이터를 기준으로 판매 기간(기본, 추가 예약 포함)과 재고를 먼저 판단하여 UI를 즉시 갱신하도록 로직을 수정하여 '추가 예약' 버그를 해결했습니다. 최종 구매 시점에는 서버를 통해 다시 한번 검증합니다.
    -   **백엔드 서비스 하위 호환성 확보**: `productService.ts`의 `checkProductAvailability` 함수를 수정하여, `salesHistory`의 존재 여부를 먼저 확인하고 데이터 구조에 따라 유연하게 재고를 확인할 수 있도록 개선했습니다. 이를 통해 구형 데이터 조회 시 발생하던 `TypeError`를 원천적으로 해결했습니다.
    -   **옵션 선택 로직 안정화**: 드롭다운 메뉴의 각 옵션을 식별하는 기준을 `id`가 아닌 **배열의 순서(index)**로 변경했습니다. 이를 통해 데이터베이스에 `id`가 누락된 경우에도 모든 옵션이 안정적으로 동작하도록 보장했습니다.
    -   **UX 추가 개선**:
        -   로딩 시 단순 스피너 대신 **스켈레톤 UI**를 표시하여 체감 성능을 향상시켰습니다.
        -   옵션 변경 시 **토스트 알림**으로 피드백을 주어 사용자가 선택을 명확히 인지하도록 했습니다.
        -   '앵콜 요청' 버튼은 **판매가 완전히 종료되거나 품절된 상품**에만 표시되도록 규칙을 명확히 하여 사용자 혼동을 줄였습니다.

### 13. 모달 닫기 후 스크롤 위치 초기화 문제 최종 해결 과정

-   **문제점**: 상품 상세 모달을 열었다 닫으면, 배경에 있던 목록 페이지의 스크롤 위치가 항상 최상단으로 초기화되어 사용자가 보던 위치를 잃어버리는 문제가 지속적으로 발생했습니다. 이로 인해 상단 배너가 헤더 뒤로 가려지는 등 심각한 UX 저하를 유발했습니다.

-   **시도했던 실패한 해결책들**:
    1.  **모달 라우팅**: 목록 페이지가 unmount되지 않도록 `location.state.background`를 사용했으나, 스크롤 문제 자체는 해결하지 못했습니다.
    2.  **수동 스크롤 복원**: `useRef`와 `useLayoutEffect`로 스크롤 위치를 저장하고 `window.scrollTo`로 복원하려 했으나, 브라우저의 렌더링 시점과 충돌하여 실패했습니다.
    3.  **스크롤 컨테이너 변경**: `body` 대신 별도의 `div`가 스크롤을 담당하도록 구조를 변경했지만, 문제의 근본 원인을 해결하지는 못했습니다.
    4.  **`createBrowserRouter` 도입**: React Router의 최신 데이터 라우터와 `<ScrollRestoration>`을 사용했으나, 오히려 다른 종류의 오류를 발생시켰습니다.

-   **진짜 원인 및 최종 해결책**:
    -   **원인**: 문제의 근본 원인은 **`position: fixed`로 고정된 헤더**와 **`body`의 `overflow`를 동적으로 변경하는 로직**의 조합이었습니다. 모달이 닫히면서 `body`의 스크롤바가 다시 나타나는 순간, 브라우저는 `fixed` 헤더를 기준으로 전체 문서의 높이를 재계산하는 과정에서 스크롤 위치를 잘못 판단하여 `0`으로 초기화시켰습니다.
    -   **해결 (구조적 접근)**:
        1.  **`position: sticky`로 헤더 변경**: 헤더의 CSS `position`을 `fixed`에서 **`sticky`**로 변경했습니다. `sticky` 속성은 헤더가 평소에는 문서 흐름 내에서 자신의 공간을 차지하다가, 스크롤될 때만 상단에 고정되므로 레이아웃 계산이 훨씬 안정적입니다. 이로 인해 불필요한 `padding-top`을 제거할 수 있었습니다.
        2.  **단순화된 스크롤 제어**: 안정적인 `sticky` 레이아웃을 기반으로, `CustomerLayout.tsx`에서 모달의 상태에 따라 **`body`의 `overflow`만 제어**하는 가장 단순한 `useLayoutEffect` 로직을 다시 적용했습니다. 레이아웃이 안정되니, 이 단순한 방법이 마침내 의도대로 정확하게 동작하여 스크롤 위치가 완벽하게 유지되었습니다.

### 14. 상품 등록/수정 페이지 UI/UX 최종 개편

-   **문제점**: 초기 상품 등록/수정 페이지는 정보 입력 필드가 여러 섹션에 분산되어 있어 스크롤이 길었고, 레이아웃이 고정되어 있어 화면 크기에 따른 유연성이 부족했습니다. 또한, 재고나 유통기한을 각 판매 옵션마다 입력해야 하는 등 비효율적이고 혼란을 유발하는 UI 요소들이 존재했습니다.
-   **최종 해결**: 사용자 피드백을 바탕으로 '직관, 간편, 쉬움'이라는 모토 아래 페이지 구조를 전면적으로 재설계했습니다.
    -   **반응형 3단 그리드 레이아웃 도입**: Flexbox를 활용하여, 화면 너비에 따라 섹션들이 3단 → 2단 → 1단으로 자동 재배치되는 유연한 레이아웃을 구현했습니다. 이를 통해 어떤 디바이스에서도 한눈에 정보를 파악할 수 있도록 사용성을 극대화했습니다.
    -   **정보 구조 재설계 및 통합**:
        -   **이미지 업로더 통합**: 별도 섹션을 차지하던 '대표 이미지'를 '대표 상품 정보' 카드 내부에 썸네일 형태의 컴팩트한 UI로 통합하여 공간 효율성을 높였습니다.
        -   **그룹 단위 유통기한 관리**: 각 옵션별로 중복 입력해야 했던 '유통기한'을 '하위 상품 그룹' 단위로 한 번만 입력하도록 변경하여 데이터 입력의 피로도를 줄이고 일관성을 확보했습니다.
    -   **UI 단순화 및 편의성 개선**:
        -   **재고 관리 직관성 향상**: '그룹 총 재고' 개념을 도입하고, 각 옵션에서는 '차감 단위'만 설정하도록 변경하여 재고 관리 로직을 명확하고 단순하게 만들었습니다.
        -   **버튼 통합**: '낱개/묶음 옵션 추가' 버튼을 '구매 옵션 추가' 버튼 하나로 통합하여 불필요한 선택 과정을 줄였습니다.
        -   **호버 툴팁 적용**: 레이아웃을 차지하던 아이콘 툴팁을 제거하고, 라벨에 마우스를 올리면 나타나는 방식으로 변경하여 화면을 더 깔끔하게 만들었습니다.

### 15. 수량 조절 버튼 동작 충돌 및 TypeError 해결
-   **문제점**: 수량 조절 버튼을 짧게 클릭 시 수량이 2씩 오르는 현상과, 특정 상황에서 `onClickRef.current is not a function`이라는 `TypeError`가 발생했습니다.
-   **원인**: 브라우저의 `onMouseUp`과 `onClick` 이벤트가 순차적으로 발생하며 로직이 중복 호출되었고, `useLongPress` 훅이 `onClick` 콜백 함수가 없는 경우를 대비하지 못해 `undefined`를 함수처럼 호출하려다 오류가 발생했습니다.
-   **해결**: `useLongPress` 훅의 로직을 전면 재설계했습니다. "꾹 누르기"가 발동되었는지 여부를 `useRef` 플래그로 추적하고, `onClick` 이벤트 핸들러는 이 플래그가 `false`일 때만("짧은 클릭"일 때만) 동작하도록 하여 두 이벤트의 충돌을 원천적으로 차단했습니다. 또한, 콜백 함수가 있는지 확인하는 방어 코드를 추가하여 `TypeError`를 해결하고 훅의 안정성을 높였습니다.

### 16. Firestore 트랜잭션 '읽기/쓰기 순서' 오류 해결
-   **문제점**: 주문 확정 시 `Firestore transactions require all reads to be executed before all writes` 오류가 발생하며 주문이 실패했습니다.
-   **원인**: `orderService.ts`의 `submitOrder` 함수 내에서, 쓰기 작업(`transaction.set`)이 발생한 이후에 다시 읽기 작업(`transaction.get`)을 수행하여 Firestore 트랜잭션의 "모든 읽기 작업 후 모든 쓰기 작업 수행" 규칙을 위반했습니다.
-   **해결**: 트랜잭션 로직을 읽기 단계와 쓰기 단계로 명확하게 분리했습니다. 트랜잭션 시작 시 필요한 모든 상품 문서를 미리 다 읽어서 변수에 저장해두고, 그 데이터를 바탕으로 재고 계산 및 분배를 마친 뒤, 마지막에 모든 쓰기(주문 생성, 대기 명단 업데이트) 작업을 순차적으로 수행하도록 구조를 변경하여 문제를 해결했습니다.

### 17. 모바일 반응형 레이아웃 깨짐 문제 해결
-   **문제점**: 일부 모바일 기기처럼 화면 너비가 좁은 환경에서 `CartPage`의 상품 카드 내부 요소들이 카드 밖으로 튀어나가는 등 레이아웃이 깨졌습니다.
-   **원인**: 고정된 `gap`과 `width` 값을 사용하는 Flexbox 레이아웃이 좁은 화면에 충분히 유연하게 대응하지 못했습니다.
-   **해결**: 미디어 쿼리를 사용해 레이아웃을 수직으로 쌓는 대신, Flexbox의 `flex-wrap: wrap` 속성을 활용하여 공간이 부족할 때 내부 요소(수량 조절 버튼, 가격 등)가 자연스럽게 아래로 줄바꿈되도록 수정했습니다. 또한, Flexbox의 자식 요소가 부모보다 작아질 수 있도록 `min-width: 0`을, 긴 텍스트가 레이아웃을 깨지 않도록 `text-overflow: ellipsis`를 적용하여 유연하고 깨지지 않는 반응형 디자인을 구현했습니다.

### 18. 상세 페이지 하단 고정 UI 렌더링 문제 최종 해결
-   **문제점**: 상품 상세 모달의 하단 구매 영역(수량 조절, 담기 버튼 등)이 화면에 보이지 않거나 다른 요소에 가려지는 문제가 반복적으로 발생했습니다. `position: fixed`와 `z-index`를 조정하는 방식으로는 근본적인 해결이 어려웠습니다.
-   **원인**: 문제의 근본 원인은 **CSS의 `position: fixed` 속성과 JSX의 구조적인 문제**였습니다. 하단 주문창을 `position: fixed`로 고정하면서, 스크롤되는 메인 컨텐츠와 분리된 별개의 레이어처럼 동작하게 되었습니다. 이로 인해 주문창이 다른 요소에 가려지거나, 의도치 않은 위치에 렌더링되어 보이지 않는 현상이 발생한 것입니다. 또한, 스크롤 영역을 담당하는 부모와 자식 요소에 `flex-grow: 1` 속성이 중첩되어 레이아웃 계산 충돌을 일으키기도 했습니다.
-   **해결 (구조적 접근)**: `position: fixed`를 사용하는 대신, **Flexbox 레이아웃만으로 UI를 전면 재구성**했습니다.
    1.  **JSX 구조 변경**: 모달 전체(`product-detail-modal-content`)를 flex 컨테이너로 만들고, 그 안에 **'스크롤 영역'(`.modal-scroll-area`)**과 **'하단 구매 영역'(`.product-purchase-footer`)**을 형제 요소로 배치하여 역할을 명확히 분리했습니다.
    2.  **CSS 수정**: 스크롤 영역에는 `flex-grow: 1`과 `overflow-y: auto`를 적용하여 남은 공간을 모두 차지하고 자체적으로 스크롤되도록 하고, 하단 구매 영역에는 `flex-shrink: 0`을 적용하여 크기가 줄어들지 않도록 했습니다. 레이아웃을 깨트리던 중복 `flex-grow` 속성은 제거했습니다.
    3.  **결과**: 이 구조적 변경을 통해 `z-index`나 `position` 속성에 의존하지 않고도, 하단 주문창이 항상 모달의 맨 아래에 안정적으로 고정되는 UI를 최종적으로 구현했습니다.

### 19. 전역 타입 시스템 안정화 및 타입 충돌 해결 과정

-   **문제점**: 프로젝트 곳곳에서 `Notification` (필요 속성 누락), `OrderItem` (필드 누락), `Order` (Timestamp와 FieldValue 혼용) 등 타입 정의가 다르거나 불완전하여 예측 불가능한 타입 오류가 지속적으로 발생했습니다. 이는 TypeScript의 강점을 제대로 활용하지 못하고 잠재적인 런타임 버그의 원인이 되었습니다.
-   **해결 과정**:
    -   **타입 정의 중앙화**: 모든 핵심 비즈니스 로직에 사용되는 타입을 `src/types.ts` 파일에서만 관리하는 **'단일 진실 공급원(Single Source of Truth)'** 원칙을 확립했습니다.
    -   **타입 통일 및 확장**:
        -   `Notification` 타입에 `read: boolean` 속성을 필수로 추가하여 `AuthContext`와 `Header` 컴포넌트 간의 타입 불일치를 해결했습니다.
        -   `OrderItem` 타입에 `category`, `subCategory`, `stock`, `arrivalDate`, `expirationDate`와 같은 필수 또는 선택적 필드들을 추가하여 `as any` 캐스팅 없이도 안전하게 데이터에 접근하도록 했습니다.
        -   `Order` 타입의 `createdAt` 필드가 `Timestamp | FieldValue`일 가능성을 명확히 하여 타입 오류를 방지했습니다.
    -   **개선 효과**: 코드 전반에서 `as any`와 같은 불필요한 타입 캐스팅을 제거하고 엄격한 타입 안정성을 확보했습니다. 이를 통해 개발 과정에서의 오류를 조기에 감지하고, 향후 발생할 수 있는 잠재적 런타임 버그를 원천적으로 차단하여 코드의 유지보수성과 견고성을 크게 향상시켰습니다.

### 20. 관리자 대시보드 기능 점진적 고도화

-   **문제점**: 초기 관리자 페이지에는 판매 현황을 한눈에 볼 수 있는 대시보드가 부재했으며, 재고를 공유하는 상품(예: 낱개/묶음)을 개별적으로 표시하여 재고 파악이 어렵고 관리 효율이 떨어졌습니다.
-   **개선 과정**: 사용자(관리자)의 실제 업무 흐름에 맞춰 다음과 같이 점진적으로 기능을 고도화했습니다.
    1.  **초기 기획**: '판매 중인 상품'과 '발주 완료된 상품'을 두 개의 섹션으로 나누는 초기 아이디어를 구상했습니다.
    2.  **핵심 문제 인식 및 방향 전환**: 여러 옵션이 하나의 재고를 공유하는 비즈니스 로직을 정확히 반영하는 것이 더 중요하다는 것을 파악하고, **'하위 상품 그룹(`VariantGroup`)'을 하나의 단위로 묶어 표시**하는 현재의 '통합 대시보드' 방식으로 방향을 전면 수정했습니다.
    3.  **데이터 표시 로직 개선**: '설정된 재고'를 표시할 때, 그룹 전체의 공유 재고(`totalPhysicalStock`)를 우선적으로 보여주되, 이 값이 설정되지 않은 경우에는 그룹 내 첫 번째 옵션의 개별 재고(`item.stock`)를 대신 표시하도록 로직을 개선하여 데이터가 누락되어 보이는 문제를 해결했습니다.
-   **개선 효과**: 단순 목록 표시에 그치지 않고, 복잡한 재고 공유 로직을 정확하게 반영하는 비즈니스 인텔리전스 도구로 발전했습니다. 이를 통해 관리자는 실제 재고 현황을 직관적으로 파악하고, 1차 마감 후 발주 및 2차 판매로 이어지는 핵심 워크플로우를 효율적으로 관리할 수 있게 되었습니다.

### 21. 장바구니 페이지 훅(Hook) 규칙 위반 오류 해결

* **문제점**: 장바구니 페이지(`CartPage.tsx`)에서 수량 조절 버튼을 길게 누르는 기능을 구현하기 위해 `useLongPress` 커스텀 훅을 사용했으나, "Rendered fewer hooks than expected" 오류가 발생하며 앱이 중단되는 문제가 있었습니다.
* **원인**: `useLongPress` 훅이 컴포넌트의 최상위 레벨이 아닌, 반복문(`.map`) 내부의 일반 함수 안에서 조건부로 호출되어 React의 훅 규칙을 위반했습니다.
* **해결**:
    * **컴포넌트 분리**: 문제가 된 상품 카드 UI와 로직을 별도의 `CartItemCard` 컴포넌트로 분리했습니다.
    * **안전한 훅 호출**: 분리된 `CartItemCard` 컴포넌트의 최상위 레벨에서 `useLongPress` 훅을 호출하도록 구조를 변경하여, 훅의 규칙을 준수하고 오류를 근본적으로 해결했습니다. 이 리팩터링을 통해 코드의 재사용성과 가독성도 함께 향상시켰습니다.

### 22. 카테고리 관리 기능의 구조적 분리 및 재설계

* **문제점**: 초기 카테고리 관리 페이지는 카테고리의 구조(생성, 수정)를 정의하는 기능과 상품에 카테고리를 '지정'하는 기능이 혼재되어 있어 역할이 불분명하고 확장성이 떨어졌습니다.
* **해결**: 사용자(관리자)의 작업 흐름에 맞춰 두 페이지의 역할을 명확하게 분리하고 재설계했습니다.
    1.  **카테고리 '구조' 관리 (`CategoryManagementPage.tsx`)**: 이 페이지는 이제 대분류 카테고리를 생성, 수정, 삭제하고 순서를 정하는 **'폴더 관리'** 역할에만 집중합니다. 복잡성을 유발하던 하위 카테고리 기능은 제거하여 시스템을 단순화했습니다.
    2.  **상품 카테고리 '지정' (`ProductCategoryBatchPage.tsx`)**: POS 시스템과 유사한 2단 레이아웃의 새로운 페이지를 만들어, 상품을 특정 카테고리로 **'분류하는 작업'**을 전담하도록 했습니다. 관리자는 드래그 앤 드롭으로 상품을 원하는 카테고리에 던져넣는 직관적인 방식으로 작업을 수행할 수 있습니다.
* **기대 효과**: 각 페이지의 역할과 책임이 명확해져 유지보수가 용이해졌으며, 관리자는 훨씬 효율적이고 직관적인 UI를 통해 상품을 관리할 수 있게 되었습니다.

### 23. 장바구니 대기 상품 자동화 및 UI 고도화

* **문제점**: 기존 장바구니는 품절 상품에 대한 '대기' 신청만 가능했을 뿐, 이후 재고가 확보되어도 사용자가 직접 다시 구매해야 하는 불편함이 있었습니다. 또한 데스크탑 환경에서의 UI가 비효율적이었습니다.
* **해결**:
    * **대기 상품 자동 처리 로직 도입**: 장바구니 페이지 진입 시, '대기' 상태인 상품의 실시간 재고를 자동으로 확인합니다. 재고가 확보되면 해당 상품을 '예약' 상태로 자동 전환하고, 픽업 기한이 지난 상품은 목록에서 자동 삭제하는 기능을 `CartPage.tsx`와 `productService.ts`에 구현했습니다.
    * **데스크탑 레이아웃 최적화**: 넓은 화면에서는 왼쪽에는 상품 목록, 오른쪽에는 주문 요약 정보가 표시되는 **2단 그리드 레이아웃**을 적용하여 전문성을 높였습니다.
    * **재고 초과 방지**: 상품 수량을 늘릴 때, 구매 가능한 재고 이상으로 수량을 늘릴 수 없도록 '+' 버튼을 비활성화하고 토스트 알림으로 피드백을 주는 기능을 추가했습니다.
* **개선 효과**: 사용자는 재고 변동을 신경 쓸 필요 없이 자동으로 예약을 확정받을 수 있게 되었고, 관리자는 수동 안내의 부담을 덜게 되었습니다. 데스크탑 UI 개선으로 사용 편의성 또한 크게 향상시켰습니다.

### 24. 통합 판매 관리 페이지 내 대기자 관리 기능 구현

* **문제점**: 기존에는 대기자 명단을 확인하고 재고를 추가하여 예약을 전환시키는 관리 기능이 부재했습니다. 별도의 페이지를 신설하는 안도 있었으나, 관리 동선이 복잡해질 우려가 있었습니다.
* **해결**: '통합 판매 관리' 페이지의 직관성을 극대화하는 **'드릴다운(Drill-down)'** 방식을 채택했습니다.
    1.  **UI 통합**: '예약/대기' 컬럼의 대기자 수를 클릭하면, 해당 판매 회차의 대기자 명단(신청 순서, 이름, 수량)을 보여주는 **모달 창**이 바로 열리도록 UI를 개선했습니다.
    2.  **백엔드 로직 구현**:
        * `getWaitlistForRound`: 특정 회차의 대기자 명단을 효율적으로 조회하는 함수를 신설했습니다.
        * `addStockAndProcessWaitlist`: 관리자가 모달에서 추가 재고를 입력하면, **선착순(FIFO)** 원칙에 따라 대기자를 예약으로 자동 전환하는 트랜잭션 함수를 구현했습니다. 이 과정에서 각 사용자의 정확한 옵션(itemId, variantGroupId)을 참조하여 주문을 생성하고, 사용자 정보도 함께 기록하도록 로직의 정확성을 확보했습니다.
* **개선 효과**: 관리자는 여러 페이지를 이동할 필요 없이, 가장 자주 보는 '통합 판매 관리' 페이지 내에서 직관적으로 대기 현황을 파악하고 재고 추가 및 예약 전환까지 원스톱으로 처리할 수 있게 되어 업무 효율성이 크게 향상되었습니다.

### 25. 관리자 페이지 라우팅 버그 수정
-   **문제점**: 상품 목록 페이지(`ProductListPageAdmin.tsx`)에서 수정 버튼 클릭 시, 필수 파라미터인 `roundId`가 URL에 포함되지 않아 수정 페이지로 이동할 수 없는 문제가 있었습니다.
-   **원인**: `Maps` 함수 호출 시 `productId`만 전달했고, `main.tsx`의 라우터 설정에도 `:roundId` 파라미터가 정의되어 있지 않았습니다.
-   **해결**: `main.tsx`의 상품 수정 경로를 `/products/edit/:productId/:roundId`로 수정하고, `ProductListPageAdmin.tsx`의 수정 버튼 클릭 이벤트에서 `roundId`를 함께 전달하도록 변경하여 문제를 해결했습니다.

### 26. 상품 등록 페이지 기능 및 UI 개선
-   **문제점**: 상품 등록 시 이미지 순서를 변경할 수 없었고, 유사한 이름의 상품이 이미 등록되어 있는지 확인할 방법이 없었습니다. 또한, 이미지 드래그앤드롭 기능 구현 후 특정 상황에서 레이아웃이 깨지는 문제가 발생했습니다.
-   **해결**:
    1.  **이미지 순서 변경**: `react-beautiful-dnd` 라이브러리를 도입하여 업로드된 이미지 썸네일을 마우스로 드래그하여 순서를 변경하는 기능을 구현했습니다.
    2.  **레이아웃 문제 해결**: 드래그앤드롭 기능과 `flex-wrap: wrap` 속성의 충돌로 인해 발생한 레이아웃 문제를, 이미지 컨테이너에 `overflow-x: auto`를 적용하고 부모 그리드 아이템에 `min-width: 0`을 설정하여 해결했습니다.
    3.  **중복 상품 리마인더**: `productService.ts`에 `searchProductsByName` 함수를 추가하고, 상품명 입력란에 디바운싱(debouncing)을 적용하여 사용자가 타이핑을 멈췄을 때 유사 상품을 자동으로 검색하여 알려주는 기능을 구현했습니다.

### 27. 전역 로딩 UI 시스템 통일
-   **문제점**: 프로젝트 전반에 걸쳐 로딩 스피너의 구현 방식(인라인 컴포넌트, 단순 div 태그 등)이 비일관적이었고, 로딩 상황(전체 페이지 vs 부분)에 대한 고려가 부족했습니다.
-   **해결**: 두 가지 목적의 공용 로더 컴포넌트를 `src/components/common`에 생성하여 프로젝트 전체의 로더를 통일했습니다.
    -   **`SodomallLoader.tsx`**: 화면 전체를 덮는 오버레이 로더로, 페이지 전환이나 권한 확인 등 전체 상호작용을 막아야 할 때 사용합니다.
    -   **`InlineSodomallLoader.tsx`**: 특정 컨테이너 내부에서만 표시되는 로더로, `Suspense`의 `fallback`이나 페이지의 일부 콘텐츠만 로딩될 때 사용합니다.
    -   기존의 모든 로딩 UI를 이 두 컴포넌트로 교체하여 일관성을 확보하고, 경로 관련 오류들을 해결했습니다.

### 28. 빠른 예약 확인 페이지 UI/UX 개선

-   **문제점**: 전화번호로 검색 시, 결과 카드나 "결과 없음" 메시지가 화면 왼쪽에 치우쳐 나타나 어색해 보였습니다. 또한, 카드 크기가 내용에 따라 제각각이라 레이아웃이 통일되지 않았습니다.
-   **해결**:
    1.  **중앙 정렬 구현**: 검색 결과를 감싸는 Flexbox 컨테이너(`.qcp-results-container`)를 추가하여, 카드 개수와 상관없이 항상 화면 중앙에 배치되도록 수정했습니다.
    2.  **카드 크기 고정**: `QuickCheckOrderCard.css`에서 카드의 `width`와 `height`를 고정 값으로 지정하여 모든 카드가 동일한 크기를 갖도록 했습니다.
    3.  **텍스트 말줄임 처리**: 상품명이 길어 카드의 높이에 영향을 주는 것을 방지하기 위해, 최대 2줄까지만 표시하고 나머지는 말줄임표(...)로 처리하는 스타일(`-webkit-line-clamp`)을 적용했습니다.
    4.  **CSS Linter 경고 해결**: 브라우저 호환성을 위해 `-webkit-line-clamp` 속성과 함께 표준 속성인 `line-clamp`를 추가하여 Linter 경고를 해결했습니다.

### 29. 토스트 알림 미사라짐 현상 디버깅 및 안정성 확보

-   **문제점**: 모바일 환경에서 정보성 토스트 알림이 설정된 시간(4초) 후에 사라지지 않고 계속 화면에 남아있는 고질적인 문제가 발생했습니다.
-   **디버깅 과정**:
    1.  초기에는 CSS의 `z-index`, `position` 충돌 또는 애니메이션 속성 덮어쓰기를 원인으로 추정하고 관련 스타일을 수정했으나 해결되지 않았습니다.
    2.  이후 프로젝트의 진입점인 `main.tsx`와 최상위 컴포넌트인 `App.tsx`에 `<Toaster />`가 중복 선언된 것을 발견하여 하나로 통합했으나, 문제는 계속되었습니다.
    3.  브라우저 개발자 도구의 심층 분석을 통해, CSS 애니메이션 속성이 아예 적용되지 않는 것을 확인하고 문제의 원인이 CSS가 아닌 자바스크립트에 있음을 특정했습니다.
-   **진짜 원인 및 최종 해결책**:
    -   **원인**: 문제의 근본 원인은 **`CartPage` 컴포넌트의 잦은 상태 변경(Re-render)**이 `react-hot-toast` 라이브러리 **내부의 자동 해제 타이머를 계속 초기화**시켰기 때문입니다. 이로 인해 타이머가 4초에 도달하지 못하고 계속 리셋되어 토스트가 사라지지 않았습니다.
    -   **해결**: `react-hot-toast`의 내부 타이머에 의존하는 대신, **독립적인 JavaScript `setTimeout`을 사용하여 수동으로 토스트를 제어**하는 `showToast` 헬퍼 함수를 구현했습니다. 이 함수는 토스트 생성 시 라이브러리의 타이머는 비활성화(`duration: Infinity`)하고, React 렌더링 사이클의 영향을 받지 않는 별도의 타이머를 동작시켜 4초 후에 `toast.dismiss()`를 호출하는 방식입니다. 이를 통해 어떤 상황에서도 토스트가 안정적으로 자동 해제되도록 문제를 최종 해결했습니다.

### ✅ [신규] 30. 상품 등록/수정 페이지 통합 리팩토링

* **문제점**: `ProductAddAdminPage`와 `SalesRoundEditPage`는 상품 폼(Form)이라는 동일한 목적을 가졌음에도 별도의 파일로 존재하여, UI와 로직이 거의 90% 중복되었습니다. 이로 인해 작은 수정 사항도 양쪽 모두에 반영해야 했고, 유지보수가 비효율적이며 잠재적인 버그 발생 가능성이 높았습니다.
* **해결**:
    1.  **통합 폼 컴포넌트 `ProductForm.tsx` 생성**: 중복되는 모든 UI와 상태 관리 로직을 `src/components/admin/ProductForm.tsx`라는 단일 컴포넌트로 추출하고 통합했습니다.
    2.  **모드(Mode) 기반 동작**: `ProductForm` 컴포넌트가 `mode`라는 prop ('newProduct', 'newRound', 'editRound')을 받도록 설계했습니다. 이 `mode`에 따라 데이터 로딩, 페이지 제목, 최종 제출 로직이 동적으로 변경되도록 하여 하나의 컴포넌트가 세 가지 역할을 모두 수행할 수 있게 만들었습니다.
    3.  **기존 페이지를 래퍼(Wrapper)로 전환**: `ProductAddAdminPage`와 `SalesRoundEditPage`는 이제 내부 로직 없이, 단지 `ProductForm` 컴포넌트를 올바른 `mode`로 렌더링하는 역할만 담당하는 가벼운 래퍼(wrapper) 컴포넌트로 변경되었습니다.
* **개선 효과**: 코드 중복을 획기적으로 제거하여 **유지보수성을 극대화**했습니다. 이제 상품 폼과 관련된 수정은 `ProductForm.tsx` 파일 하나만 변경하면 되므로, 개발 효율성이 크게 향상되었고 UI/UX의 일관성을 완벽하게 확보했습니다.

### ✅ 완료된 개선 사항

### 1. 성능 최적화: "더 빠르고 쾌적한 사용자 경험" (페이지네이션 및 당겨서 새로고침)

-   **내용**: 메인 페이지 진입 시 모든 상품을 불러오던 방식에서, 무한 스크롤과 당겨서 새로고침 기능을 도입했습니다. Firebase의 `limit()`과 `startAfter()` 쿼리를 사용하여 초기 로딩 시간을 비약적으로 단축하고 사용자 경험을 크게 향상시켰습니다.
-   **핵심 파일**: `ProductListPage.tsx`, `usePullToRefresh.ts`

### N. 컴포넌트 테스트 환경 구축 및 의존성 문제 해결

-   **문제점**: `ProductCard` 컴포넌트 테스트 시, 컴포넌트가 내부적으로 사용하는 `useAuth`, `useCart` 같은 Context 훅들이 실제 Firebase 연결을 시도하여 `FirebaseError`가 발생하고 테스트가 실패했습니다.
-   **원인**: 컴포넌트 단위 테스트는 외부 서비스와 완전히 분리되어야 하지만, 테스트 환경에서 실제 Provider(`AuthProvider`, `CartProvider`)를 사용하여 의도치 않은 외부 연결이 발생했습니다.
-   **해결**: Vitest의 `vi.mock` 기능을 사용하여 `useAuth`, `useCart` 훅 자체를 가짜(Mock) 함수로 대체했습니다. 이 가짜 훅은 테스트에 필요한 최소한의 데이터(예: `{ isSuspendedUser: false }`)만 반환하도록 설정하여, Firebase 연결 없이도 컴포넌트가 독립적으로 렌더링되고 동작을 검증할 수 있도록 환경을 구축했습니다.
-   **성과**: 이 과정을 통해 **테스트의 목적(단위 기능의 고립된 검증)**을 명확히 이해하고, 의존성 주입(Dependency Injection)과 모의(Mocking) 처리의 중요성을 학습했습니다.

### ✅ [신규] 상품 등록 시 'storage/unauthorized' 권한 오류 디버깅 과정

* **문제점**: 상품을 등록하거나 수정하고 저장할 때, Firebase Storage에서 `storage/unauthorized` 오류가 발생하며 이미지 파일 업로드가 실패하는 문제가 발생했습니다. 이 문제는 이전에 정상적으로 작동하던 기능에서 갑자기 나타났습니다.

* **디버깅 과정**:
    1.  **초기 진단**: 가장 먼저 의심된 것은 Firebase Storage의 보안 규칙이었습니다. 처음에는 규칙의 문법 오류를 수정하고, 관리자 역할(`role`)을 확인하는 `get()` 함수를 추가하는 방향으로 접근했습니다.
    2.  **가설 설정 (UID 불일치)**: 규칙을 수정해도 문제가 계속되자, `Firebase Authentication`의 UID와 `Firestore`에 저장된 사용자 문서의 ID가 일치하지 않을 것이라는 가설을 세웠습니다. 보안 규칙의 `get()` 함수는 두 ID가 일치해야 정상적으로 동작하기 때문입니다.
    3.  **가설 실패 및 중요 단서 발견**: 하지만 사용자(관리자)의 확인 결과, Authentication의 UID와 Firestore 문서 ID는 `kakao:4299905050`으로 완벽하게 일치했습니다. 이때 **"과거에는 이 방식으로 등록이 잘 되었다"**는 중요한 단서를 얻었습니다.
    4.  **근본 원인 파악**: 과거에 사용되던 규칙은 `allow read, write: if request.time < timestamp.date(...)` 형태로, **사용자의 역할을 전혀 확인하지 않고** 단순히 날짜에만 의존하는 임시 규칙이었습니다. 이 규칙이 만료되면서, 관리자 역할을 확인하는 **새로운 보안 규칙이 적용되기 시작**했고, 이전에는 드러나지 않았던 문제가 발생한 것이었습니다.
    5.  **최종 원인 특정**: 모든 정보(일치하는 ID, 정상적인 `role` 데이터)를 종합한 결과, 보안 규칙의 `get()` 함수가 콜론(`:`) 문자가 포함된 문서 ID(`kakao:4299905050`)를 제대로 처리하지 못하는 Firebase의 내부적인 문제 또는 매우 드문 엣지 케이스(Edge Case)일 가능성이 가장 높다고 판단했습니다.
    6.  **격리 테스트**: 이를 증명하기 위해, `get()` 함수를 제거하고 단순히 로그인 여부만 확인하는 `allow write: if request.auth != null;` 규칙으로 테스트했을 때 업로드에 성공했습니다. 이를 통해 문제의 원인이 **`get()` 함수 호출**에 있음을 최종적으로 확신했습니다.

* **진짜 원인 및 최종 해결책**:
    * **원인**: 보안 규칙의 `get()` 함수가 콜론(`:`)이 포함된 문서 ID 경로를 안정적으로 처리하지 못하는 것으로 추정되는 문제.
    * **해결**: `get()` 함수를 사용하는 대신, Firebase의 공식 권장 방식인 **커스텀 클레임(Custom Claims)**을 도입하여 문제를 우회하고 시스템을 개선했습니다.
        1.  **Cloud Function 도입 (`setUserRole`)**: 관리자가 특정 사용자에게 역할(예: `master`)을 부여하면, 해당 정보가 Firestore가 아닌 **사용자의 로그인 토큰 자체에 기록**되도록 하는 Cloud Function을 배포했습니다.
        2.  **보안 규칙 수정**: Storage 보안 규칙이 더 이상 Firestore를 조회(`get()`)하지 않고, 사용자의 로그인 토큰에 담긴 역할 정보(`request.auth.token.role`)를 직접 확인하도록 변경했습니다. (`allow write: if request.auth.token.role in ['admin', 'master'];`)
        3.  **필수 실행 절차**: 관리자 계정으로 **Cloud Function URL을 직접 호출**하여 토큰에 역할을 부여하고, **재로그인**하여 새 토큰을 발급받는 과정을 거쳐 문제를 최종 해결했습니다.

* **개선 효과**: 현재의 버그를 해결했을 뿐만 아니라, Firestore DB 조회를 없애 보안 규칙의 응답 속도를 향상시켰습니다. 또한, Firebase에서 권장하는 Custom Claims 방식을 도입하여 더 안정적이고 확장성 높은 권한 관리 시스템을 구축하게 되었습니다.

### ✅ [신규] 31. 클라이언트-서버 간 재고 불일치로 인한 장바구니 오류 해결

#### 1. 문제 상황

- **현상:** `ProductListPage` 또는 `ProductDetailPage`에서 재고가 있는 것을 확인하고 상품을 장바구니에 담았으나, 장바구니 페이지로 이동하면 "일부 상품의 재고가 부족하여 주문을 진행할 수 없습니다."라는 메시지가 뜨면서 해당 상품이 사라짐.
- **특징:** 명백히 재고가 남아있는 상황에서도 문제가 발생했으며, 간헐적이 아닌 지속적으로 재현됨.

#### 2. 원인 분석: 클라이언트-서버 간 재고 계산 방식 불일치

- **클라이언트 (정확한 방식):** `orders` 컬렉션을 직접 조회하여 **실시간 예약 수량**을 계산. 가장 정확하고 지연이 없는 방식.
- **서버 (지연되는 방식):** Cloud Function `checkCartStock`이 Firestore Trigger에 의해 **비동기적으로 집계**되는 `products` 문서의 `reservedCount` 필드를 참조함.
- **근본 원인:** 클라이언트가 상품을 장바구니에 담고, 주문 트리거가 `reservedCount`를 업데이트하기까지의 **아주 짧은 지연 시간(Race Condition)** 동안 서버는 이전 재고 상태를 참조함. 이로 인해 장바구니 검증 시점에 서버가 "재고 없음"으로 잘못 판단하게 됨.

#### 3. 해결 과정

1.  **초기 디버깅:** 클라이언트 측의 코드 문제(오타, 잘못된 상태 관리 등)로 추정하여 `ProductCard`, `ProductDetailPage` 등의 코드를 수정했으나 문제 해결에 실패.
2.  **서버 로직 분석:** 문제의 원인이 서버와의 데이터 불일치일 가능성에 무게를 두고 `functions/src/index.ts`의 `checkCartStock` 함수를 분석하여 위에서 설명한 재고 계산 방식의 불일치를 발견함.
3.  **타입 불일치 해결:** 서버 로직 수정 과정에서 `functions/src/types.ts`의 `CartItem` 타입 정의가 클라이언트와 동기화되지 않은 것을 발견하고, `stockDeductionAmount` 등 누락된 속성을 추가하여 타입 시스템을 일치시킴.
4.  **배포 검증:** 서버 코드를 수정했음에도 문제가 계속되어, TypeScript 코드가 JavaScript로 정상적으로 컴파일되고 배포되었는지 확인. `functions` 폴더 내에서 `npm run build`를 명시적으로 실행 후 재배포하여 배포 관련 문제를 배제함.
5.  **최종 해결:** `checkCartStock` 함수가 `products` 문서의 `reservedCount`를 참조하는 대신, 클라이언트와 동일하게 **`orders` 컬렉션을 직접 조회하여 실시간 예약 수량을 계산**하도록 로직을 통일함.

#### 4. 교훈

- 분산 시스템(클라이언트-서버)에서 상태를 동기화할 때, 비동기 작업으로 인한 지연 가능성을 항상 염두에 두어야 한다.
- 특히 재고와 같이 민감한 데이터의 최종 검증(Validation)은 반드시 신뢰할 수 있는 원천 데이터(Source of Truth, 이 경우 `orders` 컬렉션)를 직접 조회하여 처리해야 한다.
- 기능 수정 후 배포 시, 로컬의 소스코드뿐만 아니라 실제 빌드 및 배포 과정이 올바르게 이루어졌는지 확인하는 절차(로그 확인 등)는 매우 중요하다.

### ✅ [신규] 32. 지능형 알림톡 시스템 도입 및 외부 서비스(NHN Cloud) 연동 과정

* **도입 배경**: 고객의 픽업 경험을 향상시키고 노쇼를 체계적으로 방지하기 위해, 카카오톡 알림톡을 통한 자동화된 리마인더 시스템을 도입하기로 결정.

* **주요 과정 및 해결책**:
    1.  **외부 중계사 선정**: 카카오 알림톡 정책에 따라 API 중계사가 필요했으며, 개발 문서의 충실도와 안정성을 고려하여 **NHN Cloud**를 최종 선정함.
    2.  **복잡한 가입 및 인증 절차 해결**: NHN Cloud 가입 과정에서 '조직 생성', '사업자 서류 인증', '재직증명서 제출' 등 여러 단계의 인증 절차를 거침. 특히 1인 사업자의 재직증명서 문제는 **사업자등록증으로 대체 가능함**을 고객센터를 통해 확인하고 해결함.
    3.  **지능형 시나리오 설계**: 단순 픽업 안내를 넘어, 고객의 주문 조합(당일 마감/일반)에 따라 다른 내용의 메시지를 보내는 **2단계 알림 시스템**을 기획. (오전 9시 픽업 안내, 오후 7시 선입금 최종 안내)
    4.  **Firebase 스케줄링 함수 구현**: `functions/src/index.ts`에 `onSchedule`을 사용하여 `sendPickupReminders`와 `sendPrepaymentReminders` 두 개의 자동화 함수를 구현. Firestore DB를 조회하여 조건에 맞는 고객에게만 정확한 템플릿과 변수를 조합하여 알림톡을 발송하는 로직을 완성함.
    5.  **CORS 정책 오류 해결**: 로컬에서는 정상 작동했으나, 실제 배포 환경(`sodo-songdo.store`)에서 API 호출이 실패하는 CORS 오류 발생. 원인은 Cloud Function의 `allowedOrigins` 배열에 `https://www.sodo-songdo.store` 주소가 누락되었기 때문. `allowedOrigins`에 정확한 주소를 추가하고 재배포하여 문제를 해결함.

* **개선 효과**: 운영자의 수동 안내 없이도 모든 고객에게 시의적절한 픽업 및 선입금 안내를 자동으로 제공할 수 있게 됨. 이를 통해 고객 만족도를 높이고, 노쇼 비율을 감소시켜 운영 효율성을 크게 향상시킬 것으로 기대됨.

### ✅ [신규] 33. Cloud Functions 리팩토링 및 배포 오류 해결 과정

* **문제점**: 프로젝트 규모가 커지면서 `functions/src/index.ts` 파일이 비대해지고, 다양한 종류의 함수(Callable, Trigger, Scheduled)가 혼재되어 유지보수가 어려워졌습니다. 또한, 리팩토링 후 배포 시 `CORS`, `Permission Denied`, `Resource Already Exists` 등 복합적인 오류가 발생했습니다.

* **해결 과정**:
    1.  **아키텍처 재설계**: 단일 `index.ts` 구조를 **역할 기반의 폴더 구조**(`callable/`, `triggers/`, `scheduled/`, `http/`)로 전면 리팩토링했습니다. `index.ts`는 각 파일에서 함수들을 가져와 최종적으로 내보내는 **진입점(Entry Point)** 역할만 하도록 변경하여 코드의 응집도와 가독성을 높였습니다.
    2.  **CORS 및 함수 이름 오류 해결**: 리팩토링으로 인해 Firebase가 인식하는 함수 이름이 `submitOrder`에서 `callable-submitOrder` 등으로 변경되었습니다. 클라이언트(React 앱)에서 `httpsCallable`로 함수를 호출하는 모든 부분의 함수 이름을 새로운 규칙에 맞게 수정하여 CORS 및 함수를 찾을 수 없다는 오류를 해결했습니다.
    3.  **배포 권한 및 환경 불일치 문제 해결**:
        * `Permission Denied (403)` 오류는 배포 계정의 IAM 권한을 '소유자(Owner)'로 설정하여 해결했습니다.
        * `Bad Request (400)` 오류는 `functions/package.json`의 `engines` 노드 버전을 실제 배포 환경인 **`20`**으로 통일하고, `node_modules`와 `lib` 폴더를 삭제 후 재설치 및 재빌드(`npm install && npm run build`)하여 환경 불일치 문제를 해결했습니다.
    4.  **배포 충돌 문제 해결**: `Resource Already Exists (409)` 오류는 이전 함수가 삭제되는 동시에 새 함수가 생성될 때 발생하는 상태 불일치 문제로, **배포를 재시도**하여 자연스럽게 해결했습니다.

* **개선 효과**: 유지보수성이 뛰어난 서버리스 아키텍처를 구축했으며, 복잡한 배포 오류에 대한 체계적인 디버깅 및 해결 능력을 확보했습니다.

### ✅ [신규] 34. 인터랙티브 튜토리얼의 무한 스크롤 버그 및 UI 잘림 문제 해결
문제점:

`react-joyride`를 이용한 메인 튜토리얼 진행 중, 화면 하단의 메뉴(BottomNav)를 가리키기 위해 페이지가 자동으로 스크롤될 때, `ProductListPage`의 무한 스크롤 기능이 함께 작동하여 상품을 계속 불러오는 버그가 발생했습니다.

일부 튜토리얼 단계에서 설명창(툴팁)이 화면 하단에 가려져 내용이 잘리는 UI 문제가 있었습니다.

해결 과정:

**전역 상태 공유 (isTourRunning)**: `TutorialContext`에 튜토리얼이 현재 실행 중인지 여부를 나타내는 `isTourRunning` 상태를 추가했습니다. `ProductListPage`에서는 이 상태값을 구독하여, `isTourRunning`이 `true`일 때는 무한 스크롤 로직이 작동하지 않도록 `useEffect`의 조건문에 방어 코드를 추가하여 문제를 해결했습니다.

**툴팁 위치 조정**: 화면 하단에 위치한 요소를 설명할 때 툴팁이 잘리는 문제를 해결하기 위해, `AppTour.tsx`의 해당 튜토리얼 단계(step)에 `placement: 'top'` 옵션을 추가했습니다. 이를 통해 툴팁이 대상 요소의 위쪽에 표시되도록 하여, 어떤 상황에서도 내용이 잘리지 않도록 UI를 개선했습니다.

개선 효과: 기능 간의 상태 공유를 통해 의도치 않은 동작 충돌을 방지하는 방법을 학습했으며, 라이브러리에서 제공하는 옵션을 활용하여 UI 안정성을 높이는 경험을 했습니다.

### ✅ [신규] 35. AI 상품 등록 기능 개발 및 다단계 배포 오류 해결 과정

* **도입 배경**: 관리자의 상품 등록 업무 효율을 극대화하기 위해, 비정형적인 상품 안내 텍스트를 분석하여 상품 폼을 자동으로 채워주는 AI 기반 기능을 도입하기로 결정했습니다.

* **개발 과정**:
    1.  **UI/UX 설계**: 관리자가 '상세 설명'란에 텍스트를 붙여넣고 클릭할 `[AI로 채우기]` 버튼을 `ProductForm.tsx`에 구현했습니다.
    2.  **백엔드 구현**: `Google Gemini` API를 사용하는 Cloud Function(`parseProductText`)을 개발했습니다. 이 함수는 텍스트를 받아 상품명, 가격, 카테고리, 날짜 등을 추출하고, 사용자 요구에 맞게 상품명을 간소화하는 등 지능적인 데이터 가공을 수행합니다.
    3.  **보안 강화**: 민감한 Gemini API 키는 `functions.config()` 대신 **Google Cloud Secret Manager**에 안전하게 저장하고, 함수가 배포될 때 환경 변수로 주입받는 방식을 채택하여 보안을 강화했습니다.

* **복합적인 배포 오류 해결**: 기능 개발 후, 다음과 같은 복합적인 배포 및 실행 오류를 단계적으로 해결했습니다.
    1.  **`Skipped (No changes detected)` 오류**: 로컬에서 코드를 수정하고 빌드했음에도 Firebase CLI가 변경 사항을 감지하지 못하는 문제가 지속적으로 발생했습니다. 이는 `firebase.json`에 배포 전 자동 빌드를 수행하는 **`predeploy` 후크가 누락**되어 있었기 때문으로, 해당 설정을 추가하여 해결했습니다.
    2.  **CORS 정책 위반 오류**: 성공적으로 배포한 후에도 브라우저에서 CORS 오류가 발생했습니다. 원인은 Cloud Functions v2의 강화된 보안 정책으로, 사전 요청(preflight)이 인증 정보 없이 전송되어 차단되었기 때문입니다. **Google Cloud 콘솔에서 해당 함수의 호출 권한을 '인증되지 않은 호출 허용'으로 변경**하여 문제를 해결했습니다.
    3.  **`500 Internal Server Error`**: CORS 문제 해결 후, 함수 내부에서 `functions.config() is no longer available` 오류가 발생했습니다. 이는 Cloud Functions v2에서 더 이상 지원하지 않는 API를 호출했기 때문으로, API 키 관리 방식을 **Secret Manager**로 전환하여 최종 해결했습니다.

* **개선 효과**: 관리자의 반복적인 상품 등록 업무를 자동화하여 업무 시간을 획기적으로 단축했습니다. 또한, 개발 과정에서 발생한 복잡한 클라우드 배포, 권한, 보안 관련 문제들을 체계적으로 디버깅하고 해결하며 Firebase v2 환경에 대한 깊은 이해를 얻었습니다.

# Cloud Function 배포 및 실행 오류

## 배포 시 `admin.initializeApp is not a function` 오류

-   **원인**: `firebase-admin` 라이브러리를 잘못된 방식으로 `import` 했을 때 발생합니다. `import * as admin from "firebase-admin"` 와 같이 네임스페이스로 불러오는 대신, 기본(default)으로 내보내는 객체를 가져와야 합니다.
-   **해결**: `functions` 폴더 내 모든 파일에서 `import admin from "firebase-admin";` 구문을 사용하여 `import` 방식을 통일합니다.

## 배포 시 `The default Firebase app already exists` 오류

-   **원인**: Cloud Function을 배포하기 위해 코드를 분석하는 과정에서 `admin.initializeApp()`이 두 번 이상 호출될 때 발생합니다. `index.ts` 외 다른 파일에도 초기화 코드가 중복으로 포함되어 있을 수 있습니다.
-   **해결**: `functions/src/index.ts` 파일에서 `admin.initializeApp()` 코드를 아래와 같이 수정하여, 이미 초기화된 앱이 없을 때만 실행되도록 보장합니다.

    ```typescript
    if (admin.apps.length === 0) {
      admin.initializeApp();
    }
    ```

## 실행 시 `500 (Internal Server Error)` 또는 `INTERNAL` 오류

-   **원인**: 배포는 성공했지만, 서버에서 함수가 실행되던 중 내부적으로 충돌했을 때 발생합니다.
-   **해결**:
    1.  **Google Cloud 콘솔의 '로그 탐색기'**에서 해당 함수의 로그를 확인하여 실제 서버 측 오류를 파악하는 것이 가장 중요합니다.
    2.  **주요 원인 1: `admin.firestore is not a function`**: `functions` 폴더 내 파일들 간의 `import admin from "firebase-admin"` 방식이 일치하지 않을 때 발생합니다. 모든 파일에서 동일한 방식으로 `import` 해야 합니다.
    3.  **주요 원인 2: `FAILED_PRECONDITION` (색인 누락)**: Firestore 쿼리에 필요한 색인(Index)이 없어 발생하는 오류입니다. 오류 로그에 포함된 `https://console.firebase.google.com/...` 링크를 클릭하여 자동으로 색인을 생성할 수 있습니다.

### ✅ [신규] 36. 클라이언트-서버 역할 분리 및 Cloud Functions 연동 오류 해결
문제점: 클라이언트(React)와 서버(Cloud Functions)의 역할이 명확히 분리되지 않아 복합적인 오류가 발생했습니다.
1.  **권한 오류**: 고객 페이지(`ProductListPage.tsx`)가 모든 `orders` 문서를 직접 읽으려다 Firestore 보안 규칙에 의해 차단되었습니다. (`Missing or insufficient permissions`)
2.  **CORS 오류**: 서버 함수를 호출할 때, 허용된 출처(`allowedOrigins`) 설정이 미비하여 브라우저가 요청을 차단했습니다.
3.  **서버 전용 코드 오류**: `addStockAndProcessWaitlist`와 같이 서버에서만 실행되어야 할 민감한 로직이 클라이언트 코드(`src/firebase/productService.ts`)에 포함되어, `Transaction` 타입 불일치 등 지속적인 오류를 유발했습니다.
해결 과정:
1.  **서버 로직 이전**: 클라이언트의 `getReservedQuantitiesMap` 로직을 `getProductsWithStock` Cloud Function으로 이전하여, 서버가 모든 계산을 마친 후 안전한 결과만 클라이언트에 전달하도록 아키텍처를 변경했습니다.
2.  **역할 기반 분리**: `addStockAndProcessWaitlist`와 같은 모든 서버 전용 로직을 `functions/src/callable/` 폴더 내의 전용 Cloud Function으로 이전하고, 클라이언트 페이지들은 `httpsCallable`을 통해 이 함수들을 호출하도록 수정했습니다.
3.  **중앙 설정 및 `import` 경로 정리**: `functions/src/firebase/admin.ts` 파일을 생성하여 Firebase Admin SDK 초기화와 CORS 설정을 중앙에서 관리하도록 통일했습니다. 또한, 서버(`functions`)와 클라이언트(`src`) 간의 `import` 경로가 섞이지 않도록 모든 경로를 재검토하고 수정하여 코드의 실행 환경을 명확히 분리했습니다.
개선 효과: 클라이언트와 서버의 역할을 명확히 분리하여 보안과 안정성을 크게 향상시켰습니다. 또한, 코드의 응집도를 높이고 의존성을 단순화하여 향후 유지보수 및 디버깅이 매우 용이해졌습니다.

### ✅ [신규] 37. 대기 목록 기능 관련 버그 수정
문제점:
1.  '대기 확정' 후, `OrderHistoryPage.tsx`의 '대기 목록' 탭에 신청 내역이 표시되지 않았습니다.
2.  관리자가 재고를 추가해도 대기자가 예약으로 전환되었다는 앱 내 알림이 고객에게 발송되지 않았습니다.
3.  이미 대기 중인 상품의 수량을 추가하고 싶어도, "이미 대기를 신청한 상품입니다" 오류가 발생하며 막혔습니다.
원인 분석:
1.  `OrderHistoryPage`가 존재하지 않는 서버 함수를 호출하여 데이터를 가져오지 못했습니다.
2.  알림 생성 함수(`createNotification`)가 서버 환경이 아닌 클라이언트용으로 구현되어 있었습니다.
3.  `addWaitlistEntry` 함수가 신규 신청만 가정하고, 기존 신청의 수량을 업데이트하는 로직이 없었습니다.
해결:
1.  **`OrderHistoryPage` 수정**: 잘못된 서버 함수 호출을 제거하고, `src/firebase/productService.ts`에 있는 **클라이언트용 `getUserWaitlist` 함수**를 직접 호출하도록 수정하여 문제를 해결했습니다.
2.  **서버용 유틸리티 생성**: `functions/src/utils/notificationService.ts`를 새로 만들어 서버 환경에서 알림을 생성하는 로직을 구현하고, `stock.ts` Cloud Function이 이를 호출하도록 수정했습니다.
3.  **`addWaitlistEntry` 로직 개선**: `waitlist.ts` Cloud Function을 수정하여, 동일한 상품에 대한 대기 신청이 다시 들어오면 기존 대기 수량에 새로운 수량을 더하도록 로직을 개선했습니다.

### ✅ [신규] 38. Cloud Functions 다단계 배포 오류 디버깅
문제점: Cloud Functions 리팩토링 후, firebase deploy 명령어 실행 시 initializeApp, 모듈 로딩 순서, import 문법 등 다양한 원인으로 배포 전 분석 단계에서 런타임 오류가 반복적으로 발생했습니다.
오류 로그:
`TypeError: admin.auth is not a function`
`FirebaseAppError: The default Firebase app does not exist.`
`TypeError: Cannot read properties of undefined (reading 'length')`
`Cannot find module ... Did you mean '...js'?`
원인: Node.js의 ES Modules 로딩 순서와 CommonJS import 방식 간의 차이를 고려하지 않은 것이 핵심 원인이었습니다. `index.ts`에서 다른 파일을 import하고, 그 파일들이 다시 설정 파일(`config.ts`)을 import하는 과정에서, `initializeApp()`이 실행되기 전에 `getAuth()` 등이 먼저 호출되는 타이밍 문제가 발생했습니다.
최종 해결:
**단일 진실 공급원 확립**: `functions/src/firebase/admin.ts`라는 독립적인 파일을 생성하여, Firebase Admin SDK 초기화와 `dbAdmin`, `authAdmin` 객체 생성, `allowedOrigins` 설정을 모두 이 파일에서 책임지도록 했습니다.
**의존성 단순화**: 다른 모든 Cloud Function 파일(`products.ts`, `orders.ts` 등)은 이제 오직 `admin.ts` 파일 하나만 import하여 준비된 `dbAdmin`, `authAdmin` 객체를 사용하도록 구조를 단순화했습니다.
**import 문법 통일**: `tsconfig.json`의 `moduleResolution` 설정에 따라, 모든 상대 경로 import 구문에 `.js` 확장자를 명시하는 것으로 문법을 통일하여 모듈 해석 오류를 해결했습니다.
개선 효과: 복잡한 모듈 로딩 순서에 의존하지 않는, 매우 안정적이고 예측 가능한 서버 아키텍처를 구축했습니다.

### ✅ [신규] 39. 앱 전체 성능 저하 현상 (Non-Passive Listener) 및 React.lazy를 통한 해결

* **문제점**: `OrderHistoryPage` 등 앱의 여러 페이지에서 스크롤 시 버벅이는 등 전반적인 반응 속도가 심각하게 느려졌습니다. 브라우저 콘솔에는 `react-kakao-maps-sdk`에서 발생하는 'Added non-passive event listener' 경고가 지속적으로 출력되었습니다.
* **원인**: `CustomerCenterPage`의 '매장 정보' 탭(`InfoTab`)에 포함된 `KakaoMap` 컴포넌트가, 해당 탭이 보이지 않을 때도 미리 로딩되어 앱의 메인 스레드를 계속 점유하고 있었습니다. 이로 인해 지도의 이벤트 리스너들이 다른 모든 페이지의 사용자 인터랙션(스크롤, 터치 등)까지 방해하여 앱 전체의 성능 저하를 유발했습니다.
* **해결**: React의 **지연 로딩(Lazy Loading)** 기법을 도입했습니다. `CustomerCenterPage.tsx`에서 `InfoTab` 컴포넌트를 `React.lazy()`를 사용해 동적으로 import하고, UI를 `<Suspense>`로 감싸주었습니다. 이 방법을 통해 사용자가 '매장 정보' 탭을 실제로 클릭하기 전까지는 무거운 지도 관련 코드를 일절 로드하지 않도록 수정하여, 앱의 초기 로딩 속도와 전반적인 반응성을 크게 향상시켰습니다.

### ✅ [신규] 40. '순서 올리기' 기능 다단계 디버깅 (Permission Denied → Bad Request)

* **문제점**: '1등 고정하기' 버튼 클릭 시, 처음에는 `Missing or insufficient permissions` (Firestore 보안 규칙 위반) 오류가 발생했고, 이를 해결하자 `400 Bad Request` ("필수 정보 누락") 오류가 발생하는 등 복합적인 문제가 나타나며 페이지가 멈췄습니다.
* **디버깅 과정**:
    1.  **`Permission Denied` 오류 해결**: 초기 오류는 클라이언트(브라우저)에서 직접 `products` 컬렉션을 수정하려 했기 때문에 발생했습니다. 민감한 로직을 클라이언트(`pointService.ts`)에서 분리하여 **안전한 서버 환경의 Cloud Function(`useWaitlistTicket`)으로 이전**하는 아키텍처 변경을 통해 권한 문제를 해결했습니다.
    2.  **`Bad Request` 오류 추적**: Cloud Function으로 이전 후, 클라이언트에서는 모든 ID 값을 정상적으로 보내는 것처럼 보였으나 서버에서는 "필수 정보가 누락되었다"는 오류가 계속 발생했습니다. 서버 측(`points.ts`)에 직접 디버깅 로그를 추가하여 확인한 결과, 클라이언트에서 보낸 `{key: value}` 형태의 객체가 서버에 도착했을 때는 첫 번째 값만 남은 **단일 문자열로 변형**되는 알 수 없는 데이터 직렬화 문제를 발견했습니다.
* **최종 해결**: 데이터가 전송되는 과정의 문제를 우회하기 위해, 클라이언트의 `pointService.ts`와 `OrderHistoryPage.tsx`의 함수 호출 방식을 수정했습니다. 여러 개의 ID 값을 개별 인자로 명확하게 전달받은 후, Cloud Function을 호출하는 **바로 그 시점에 순수한 새 객체(POJO)를 만들어 전달**하도록 변경하여, 데이터가 변형 없이 서버에 도달하도록 보장하여 문제를 최종 해결했습니다.