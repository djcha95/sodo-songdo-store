import{B as d,C as s,aC as A,a1 as E,a3 as R,a2 as p,a0 as f,aq as w,D as P,an as g,aD as I,al as u,aE as D}from"./index-BMz7zIRN.js";const b=async e=>{const t=d(s,"orders",e.id);await A(s,async a=>{const r=await a.get(t);if(!r.exists())throw new Error("주문 정보를 찾을 수 없습니다.");const n=r.data();if(n.status!=="RESERVED"&&n.status!=="PREPAID")throw new Error("예약 또는 결제 완료 상태의 주문만 취소할 수 있습니다.");a.update(t,{status:"CANCELED",canceledAt:u()})})},U=async(e,t)=>{if(e.length===0)return;const a=w(s);let r=null;t==="PICKED_UP"&&(r="pickedUpAt"),t==="PREPAID"&&(r="prepaidAt"),t==="CANCELED"&&(r="canceledAt"),e.forEach(n=>{const o=d(s,"orders",n),c={status:t};r&&(c[r]=u()),a.update(o,c)}),await a.commit()},$=async(e,t,a)=>{if(t<=0)throw new Error("픽업 수량은 1 이상이어야 합니다.");await A(s,async r=>{const n=d(s,"orders",e),o=await r.get(n);if(!o.exists())throw new Error("분할할 원본 주문을 찾을 수 없습니다.");const c={id:e,...o.data()},l=c.items[0],i=l.quantity-t;if(i<=0)throw new Error("남는 수량이 없어 주문을 분할할 수 없습니다. 일반 상태 변경을 이용해주세요.");const m={...l,quantity:i},q={...c,orderNumber:`${c.orderNumber}-REMAIN`,items:[m],totalPrice:m.unitPrice*i,status:a,createdAt:u(),splitFrom:e,notes:`[${c.orderNumber}]에서 분할된 ${a} 주문`},y=d(p(s,"orders"));r.set(y,q);const h={...l,quantity:t},O={items:[h],totalPrice:h.unitPrice*t,status:"PICKED_UP",pickedUpAt:u(),notes:`[${y.id}]로 ${i}개 분할 처리됨`};r.update(n,O)})},N=async e=>{if(!e)return[];const t=E(p(s,"orders"),R("userId","==",e),g("createdAt","desc"));return(await f(t)).docs.map(r=>({id:r.id,...r.data()}))},M=async()=>{const e=E(p(s,"orders"),g("createdAt","desc"));return(await f(e)).docs.map(a=>({id:a.id,...a.data()}))},k=async(e,t)=>{const a=w(s);e.forEach(r=>{const n=d(s,"orders",r),o={status:"RESERVED"};t==="PICKED_UP"?o.pickedUpAt=D():t==="PREPAID"&&(o.prepaidAt=D()),a.update(n,o)}),await a.commit()},v=async(e,t)=>{await P(d(s,"orders",e),{notes:t})},B=async(e,t)=>{await P(d(s,"orders",e),{isBookmarked:t})},F=async e=>{const t=d(s,"orders",e);await I(t)},x=async e=>{const t=w(s);e.forEach(a=>{const r=d(s,"orders",a);t.delete(r)}),await t.commit()},K=async()=>{const e=new Map,t=E(p(s,"orders"),R("status","in",["RESERVED","PREPAID"]));return(await f(t)).forEach(r=>{(r.data().items||[]).forEach(o=>{const c=`${o.productId}-${o.roundId}-${o.variantGroupId}`;e.set(c,(e.get(c)||0)+o.quantity)})}),e};export{N as a,v as b,b as c,M as d,F as e,x as f,K as g,k as r,$ as s,B as t,U as u};
