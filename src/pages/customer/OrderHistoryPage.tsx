// src/pages/customer/OrderHistoryPage.tsx

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { useTutorial } from '@/context/TutorialContext';
import { orderHistoryTourSteps } from '@/components/customer/AppTour';
import { cancelOrder } from '@/firebase/orderService';
import { getUserWaitlist, cancelWaitlistEntry } from '@/firebase/productService';
import { getApp } from 'firebase/app';
import { getFunctions, httpsCallable, type HttpsCallableResult } from 'firebase/functions';
// useLongPress Ï†úÍ±∞
// import useLongPress from '@/hooks/useLongPress';
import type { Order, OrderItem, OrderStatus } from '@/types';
import { Timestamp } from 'firebase/firestore';
import { motion, AnimatePresence } from 'framer-motion';
import dayjs from 'dayjs';
import {
  Package, ListOrdered, Truck, CircleCheck, AlertCircle, PackageCheck,
  PackageX, Hourglass, CreditCard, Inbox, Info, Bolt, XCircle, Plus, Minus
} from 'lucide-react';
import InlineSodomallLoader from '@/components/common/InlineSodomallLoader';
import { getOptimizedImageUrl } from '@/utils/imageUtils';
import toast from 'react-hot-toast';
import { showToast, showPromiseToast } from '@/utils/toastUtils';

import './OrderHistoryPage.css';

const functions = getFunctions(getApp(), 'asia-northeast3');
const updateOrderQuantityCallable = httpsCallable<{ orderId: string; newQuantity: number }, { success: boolean, message: string }>(functions, 'updateOrderQuantity');


const PLACEHOLDER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZWFmMGY0Ii8+PC9zdmc+';
const DEFAULT_EVENT_IMAGE = '/event-snack-default.png';

// ÌÉÄÏûÖ Ï†ïÏùò Ï∂îÍ∞Ä
type OrderCancellationItem = { order: Order; isPenalty: boolean; };
type WaitlistCancellationItem = WaitlistInfo;

interface WaitlistInfo {
  productId: string;
  roundId: string;
  itemId: string;
  productName: string;
  itemName: string;
  imageUrl: string;
  quantity: number;
  timestamp: Timestamp;
  waitlistOrder?: number;
  primaryReservationEndAt?: Timestamp;
}


type ThumbSize = '200x200' | '1080x1080';

const SafeThumb: React.FC<{
  src?: string; alt: string; size?: ThumbSize; eager?: boolean; className?: string;
}> = ({ src, alt, size = '200x200', eager = false, className }) => {

  const original = useMemo(() => (src && src.trim()) ? src : PLACEHOLDER, [src]);

  const optimized = useMemo(() => {
    if (original === PLACEHOLDER) return PLACEHOLDER; // üí° [Ïò§Î•ò ÏàòÏ†ï] PLACEHOLDEr -> PLACEHOLDER
    return getOptimizedImageUrl(original, size);
  }, [original, size]);

  const [imageSrc, setImageSrc] = useState(optimized);
  const [errorState, setErrorState] = useState<'none' | 'optimized-failed' | 'original-failed'>('none');

  useEffect(() => {
    const newOptimized = getOptimizedImageUrl(original, size);
    setImageSrc(newOptimized);
    setErrorState('none');
  }, [original, size]);

  const handleError = useCallback(() => {
    if (errorState === 'original-failed') {
      return;
    }

    if (errorState === 'none') {
      console.error(`[SafeThumb ERROR] Optimized image failed to load: ${optimized}`);
      console.log(`[SafeThumb FALLBACK-1] Trying original URL: ${original}`);
      setErrorState('optimized-failed');
      setImageSrc(original);
    } else if (errorState === 'optimized-failed') {
      console.error(`[SafeThumb ERROR] Original image also failed: ${original}`);
      console.log(`[SafeThumb FALLBACK-2] Displaying placeholder.`);
      setErrorState('original-failed');
      setImageSrc(PLACEHOLDER);
    }
  }, [errorState, optimized, original]);

  return (
    <img
      src={imageSrc}
      alt={alt}
      className={`${className} ${errorState !== 'none' ? 'image-error-fallback' : ''}`}
      loading={eager ? 'eager' : 'lazy'}
      fetchpriority={eager ? 'high' : 'auto'}
      onError={handleError}
    />
  );
};


interface AggregatedItem {
  id: string;
  stableId: string;
  productId: string;
  productName: string;
  variantGroupName: string;
  itemName:string;
  totalQuantity: number;
  imageUrl: string;
  originalOrders: Order[];
  status: OrderStatus;
  wasPrepaymentRequired: boolean;
}

interface CancellationDetails {
  cancellable: boolean;
  orderToCancel?: Order;
  cancelDisabledReason: string | null;
  isEvent: boolean;
  isPenaltyPeriod: boolean;
}

const safeToDate = (date: any): Date | null => {
  if (!date) return null;
  if (date instanceof Date) return date;
  if (typeof date.toDate === 'function') return date.toDate();
  if (typeof date === 'object' && (date.seconds !== undefined || date._seconds !== undefined)) {
    const seconds = date.seconds ?? date._seconds;
    const nanoseconds = date.nanoseconds ?? date._nanoseconds ?? 0;
    return new Timestamp(seconds, nanoseconds).toDate();
  }
  if (typeof date === 'string') {
    const parsedDate = new Date(date);
    if (!isNaN(parsedDate.getTime())) return parsedDate;
  }
  return null;
};

const formatSimpleDate = (date: Date): string => {
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const week = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
  const dayOfWeek = week[date.getDay()];
  return `${month}/${day}(${dayOfWeek})`;
};

// ‚úÖ [ÏàòÏ†ï] ÌîΩÏóÖÏùº Ìó§Îçî Ìè¨Îß∑ Î≥ÄÍ≤Ω (Ïòà: 10/1(Ïàò) ÌîΩÏóÖÏÉÅÌíà)
const formatPickupDateHeader = (date: Date): string => {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const week = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
  const dayOfWeek = week[date.getDay()];
  return `${month}/${day}(${dayOfWeek}) ÌîΩÏóÖÏÉÅÌíà`;
};

const formatPickupDateShort = (date: Date): string => {
  const week = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'];
  const dayOfWeek = week[(date.getDay())];
  return `${date.getMonth() + 1}/${date.getDate()}(${dayOfWeek})`;
};

const getCancellationDetails = (item: AggregatedItem): CancellationDetails => {
  const latestOrder = item.originalOrders[0];
  if (!latestOrder) {
    return { cancellable: false, orderToCancel: undefined, cancelDisabledReason: 'Ï£ºÎ¨∏ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.', isEvent: false, isPenaltyPeriod: false };
  }
  const oi = latestOrder.items?.[0];
  const isEventLike =
    (latestOrder as any)?.eventId ||
    (oi as any)?.eventId ||
    (oi as any)?.roundId?.startsWith?.('welcome-') ||
    (oi as any)?.roundName?.includes?.('Ïù¥Î≤§Ìä∏') ||
    item.productName?.includes?.('ÎûúÎç§Í∞ÑÏãù') ||
    (typeof (oi as any)?.unitPrice === 'number' && (oi as any)?.unitPrice === 0);

  if (isEventLike) {
    return { cancellable: false, orderToCancel: undefined, cancelDisabledReason: 'Ïù¥Î≤§Ìä∏ ÏÉÅÌíàÏùÄ Ï∑®ÏÜåÌï† Ïàò ÏóÜÏäµÎãàÎã§.', isEvent: true, isPenaltyPeriod: false };
  }
  
  const isCancellableStatus = latestOrder.status === 'RESERVED' || latestOrder.status === 'PREPAID';
  if (!isCancellableStatus) {
    return { cancellable: false, orderToCancel: undefined, cancelDisabledReason: null, isEvent: false, isPenaltyPeriod: false };
  }

  const createdAt = safeToDate(latestOrder.createdAt);
  const pickupDate = safeToDate(latestOrder.pickupDate);
  if (!createdAt || !pickupDate) {
      return { cancellable: false, orderToCancel: undefined, cancelDisabledReason: 'Ï£ºÎ¨∏ ÎòêÎäî ÌîΩÏóÖÏùº Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§.', isEvent: false, isPenaltyPeriod: false };
  }

  const firstPeriodDeadline = dayjs(createdAt);
  const deadlineDay = firstPeriodDeadline.day() === 6
    ? firstPeriodDeadline.add(2, 'day')
    : firstPeriodDeadline.add(1, 'day');
  const finalFirstPeriodDeadline = deadlineDay.hour(13).minute(0).second(0).millisecond(0).toDate();

  const finalCancelDeadline = dayjs(pickupDate).hour(13).minute(0).second(0).millisecond(0).toDate();
  
  const now = new Date();

  if (now > finalCancelDeadline) {
    return { cancellable: false, orderToCancel: undefined, cancelDisabledReason: 'ÌîΩÏóÖÏùº ÎßàÍ∞ê ÏãúÍ∞ÑÏù¥ ÏßÄÎÇò Ï∑®ÏÜåÌï† Ïàò ÏóÜÏäµÎãàÎã§.', isEvent: false, isPenaltyPeriod: false };
  }
  
  const isPenalty = now > finalFirstPeriodDeadline;

  return { cancellable: true, orderToCancel: latestOrder, cancelDisabledReason: null, isEvent: false, isPenaltyPeriod: isPenalty };
};

const DATA_PER_PAGE = 10;

const usePaginatedData = <T,>(
  uid: string | undefined,
  fetchFn: (payload: any) => Promise<HttpsCallableResult<any>>,
  basePayload: object,
  isActive: boolean
) => {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [lastVisible, setLastVisible] = useState<any | null>(null);

  const stateRef = useRef({ loadingMore, hasMore, lastVisible });
  stateRef.current = { loadingMore, hasMore, lastVisible };

  const fetchData = useCallback(async (isInitial = false) => {
    if (!uid) {
      setLoading(false);
      return;
    }

    if (isInitial) {
      setLoading(true);
      setHasMore(true);
      setLastVisible(null);
      setData([]);
    } else {
      if (stateRef.current.loadingMore || !stateRef.current.hasMore) return;
      setLoadingMore(true);
    }

    try {
      const cursor = isInitial ? null : stateRef.current.lastVisible;
      const payload = { ...basePayload, pageSize: DATA_PER_PAGE, lastVisible: cursor };

      const result = await fetchFn(payload);
      const responsePayload = result.data;

      const newData = Array.isArray(responsePayload) ? responsePayload : (responsePayload as any)?.data;
      const lastDoc = Array.isArray(responsePayload) ? null : (responsePayload as any)?.lastDoc;

      if (!Array.isArray(newData)) {
        setHasMore(false);
        if (isInitial) setData([]);
      } else {
        setData(prev => isInitial ? newData : [...prev, ...newData]);
        setLastVisible(lastDoc);
        if (!lastDoc || (newData as any[]).length < DATA_PER_PAGE) {
          setHasMore(false);
        }
      }
    } catch (err: any) {
      console.error('Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïò§Î•ò:', err);
      showToast('error', err.message || 'Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      // ‚úÖ [ÏàòÏ†ï] hasMoreRef -> setHasMore(false)Î°ú ÏàòÏ†ï
      setHasMore(false);
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [uid, fetchFn, basePayload]);

  useEffect(() => {
    if (isActive) {
      fetchData(true);
    }
  }, [isActive, fetchData]);

  const loadMore = useCallback(() => {
    fetchData(false);
  }, [fetchData]);

  return { data, setData, loading: loading || loadingMore, hasMore, loadMore };
};

// ‚úÖ [ÏàòÏ†ï] DateHeader Î°úÏßÅ Î≥ÄÍ≤Ω
const DateHeader: React.FC<{ date: Date, viewMode: 'pickup' | 'waitlist' }> = React.memo(({ date, viewMode }) => (
  <h2 className="date-header">
    {/* viewMode === 'orders' Î°úÏßÅ Ï†úÍ±∞ */}
    {viewMode === 'pickup' ? formatPickupDateHeader(date) : formatSimpleDate(date)} 
  </h2>
));

const EmptyHistory: React.FC<{ type?: 'order' | 'waitlist' | 'pickup' }> = React.memo(({ type = 'order' }) => {
  const navigate = useNavigate();
  const messages = {
    order: { icon: <Package size={48} className="empty-icon" />, title: 'ÏïÑÏßÅ ÏòàÏïΩ ÎÇ¥Ïó≠Ïù¥ ÏóÜÏñ¥Ïöî', desc: 'ÎßàÏùåÏóê ÎìúÎäî ÏÉÅÌíàÏùÑ Ï∞æÏïÑ ÏòàÏïΩÌï¥Î≥¥ÏÑ∏Ïöî!' },
    waitlist: { icon: <Inbox size={48} className="empty-icon" />, title: 'ÎåÄÍ∏∞Ï§ëÏù∏ ÏÉÅÌíàÏù¥ ÏóÜÏñ¥Ïöî', desc: 'ÌíàÏ†à ÏÉÅÌíàÏóê ÎåÄÍ∏∞ Ïã†Ï≤≠ÏùÑ Ìï¥Î≥¥ÏÑ∏Ïöî!' },
    pickup: { icon: <Truck size={48} className="empty-icon" />, title: 'ÏòàÏ†ïÎêú ÌîΩÏóÖÏù¥ ÏóÜÏñ¥Ïöî', desc: 'Îã§Í∞ÄÏò¨ ÌîΩÏóÖ ÏòàÏïΩÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§.' },
  }
  const { icon, title, desc } = messages[type];

  return (
    <div className="empty-history-container">
      {icon}
      <h3 className="empty-title">{title}</h3>
      <p className="empty-description">{desc}</p>
      <button className="go-to-shop-btn" onClick={() => navigate('/')}>
        ÏÉÅÌíà Î≥¥Îü¨ Í∞ÄÍ∏∞
      </button>
    </div>
  );
});

const QuantityControls: React.FC<{
  value: number;
  onUpdate: (newQuantity: number) => void;
  orderId: string;
  max?: number;
  onStockLimitDiscovered: (orderId: string, max: number) => void;
}> = ({ value, onUpdate, orderId, max, onStockLimitDiscovered }) => {
  const [currentQuantity, setCurrentQuantity] = useState(value);
  const [isUpdating, setIsUpdating] = useState(false);

  const debounceTimeout = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (max !== undefined && currentQuantity > max) {
      setCurrentQuantity(max);
    }
  }, [max, currentQuantity]);

  const handleQuantityChange = (newQuantity: number) => {
    if (newQuantity < 1) return;
    
    setCurrentQuantity(newQuantity);

    if (debounceTimeout.current) {
      clearTimeout(debounceTimeout.current);
    }

    debounceTimeout.current = setTimeout(() => {
      if (newQuantity !== value) {
        setIsUpdating(true);
        const promise = updateOrderQuantityCallable({ orderId, newQuantity });
        
        showPromiseToast(promise, {
            loading: 'ÏàòÎüâ Î≥ÄÍ≤Ω Ï§ë...',
            success: (result) => {
                onUpdate(newQuantity);
                setIsUpdating(false);
                return result.data.message;
            },
            error: (err: any) => {
                setCurrentQuantity(value);
                setIsUpdating(false);
                const message = err.message || 'ÏàòÎüâ Î≥ÄÍ≤ΩÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
                const match = message.match(/ÏµúÎåÄ (\d+)Í∞ú/);
                if (match && match[1]) {
                    const maxQuantity = parseInt(match[1], 10);
                    onStockLimitDiscovered(orderId, maxQuantity);
                }
                return message;
            }
        });
      }
    }, 800);
  };
  
  return (
    <div className="quantity-controls">
      <button onClick={(e) => { e.stopPropagation(); handleQuantityChange(currentQuantity - 1); }} disabled={isUpdating || currentQuantity <= 1}>
        <Minus size={20} />
      </button>
      <span className="quantity-value">{isUpdating ? '...' : currentQuantity}</span>
      <button onClick={(e) => { e.stopPropagation(); handleQuantityChange(currentQuantity + 1); }} disabled={isUpdating || (max !== undefined && currentQuantity >= max)}>
        <Plus size={20} />
      </button>
    </div>
  );
};


const AggregatedItemCard: React.FC<{
  item: AggregatedItem;
  // displayDateInfo propsÎäî ÌîΩÏóÖÏùºÏàúÏúºÎ°ú Í≥†Ï†ïÎêòÎØÄÎ°ú Ï†úÍ±∞
  isSelected: boolean;
  onSelect: (id: string) => void;
  onQuantityUpdate: (orderId: string, newQuantity: number) => void;
  maxQuantity?: number;
  onStockLimitDiscovered: (orderId: string, max: number) => void;
}> = React.memo(({ item, isSelected, onSelect, onQuantityUpdate, maxQuantity, onStockLimitDiscovered }) => {

  const { statusText, StatusIcon, statusClass } = useMemo(() => {
    if (item.wasPrepaymentRequired && item.status === 'RESERVED') {
      return { statusText: 'ÏÑ†ÏûÖÍ∏à ÌïÑÏöî', StatusIcon: CreditCard, statusClass: 'status-prepayment_required' };
    }
    const textMap: Record<OrderStatus, string> = { 
        RESERVED: 'ÏòàÏïΩ ÏôÑÎ£å', 
        PREPAID: 'ÏÑ†ÏûÖÍ∏à ÏôÑÎ£å', 
        PICKED_UP: 'ÌîΩÏóÖ ÏôÑÎ£å', 
        COMPLETED: 'Ï≤òÎ¶¨ ÏôÑÎ£å', 
        CANCELED: 'Ï∑®ÏÜåÎê®', 
        NO_SHOW: 'ÌîΩÏóÖ Í∏∞Í∞Ñ ÎßåÎ£å', 
        LATE_CANCELED: 'Ï∑®ÏÜåÎê®' 
    };
    const iconMap: Record<OrderStatus, React.ElementType> = { 
        RESERVED: Hourglass, 
        PREPAID: PackageCheck, 
        PICKED_UP: PackageCheck, 
        COMPLETED: CircleCheck, 
        CANCELED: PackageX, 
        NO_SHOW: AlertCircle, 
        LATE_CANCELED: PackageX 
    };
    return {
      statusText: textMap[item.status] || 'Ïïå Ïàò ÏóÜÏùå',
      StatusIcon: iconMap[item.status] || AlertCircle,
      statusClass: `status-${item.status.toLowerCase()}`
    }
  }, [item.status, item.wasPrepaymentRequired]);


  const { cancellable, isEvent } = useMemo(() => getCancellationDetails(item), [item]);
  const isQuantityEditable = (item.status === 'RESERVED' || item.status === 'PREPAID') && item.originalOrders.length === 1;

  const isCanceledOrNoShow = useMemo(() => 
    item.status === 'CANCELED' || item.status === 'LATE_CANCELED' || item.status === 'NO_SHOW', 
    [item.status]
  );
  
  const topText = useMemo(
    () => isEvent ? item.productName : item.variantGroupName,
    [isEvent, item.productName, item.variantGroupName]
  );

  const bottomText = useMemo(
    () => isEvent ? item.originalOrders[0]?.items[0]?.roundName : item.itemName,
    [isEvent, item.originalOrders, item.itemName]
  );
    
  // ‚úÖ [ÏàòÏ†ï] useLongPress Ï†úÍ±∞ Î∞è ÏùºÎ∞ò onClickÏúºÎ°ú Î≥ÄÍ≤Ω
  const handleClick = useCallback((e: React.MouseEvent) => {
    if (isCanceledOrNoShow) return; 
    if (cancellable || (item.status === 'RESERVED' || item.status === 'PREPAID')) {
      e.preventDefault(); // ÎìúÎûòÍ∑∏ ÌõÑ ÌÅ¥Î¶≠ Ïò§Ïù∏ Î∞©ÏßÄÎ•º ÏúÑÌï¥
      onSelect(item.id);
    }
  }, [cancellable, item.status, item.id, onSelect, isCanceledOrNoShow]);
  
  // ÌîΩÏóÖÏùºÏàúÏúºÎ°ú ÌÜµÏùºÎêòÏñ¥ displayDateInfoÍ∞Ä ÌïÑÏöî ÏóÜÏñ¥Ïßê
  // let displayDateText = '';
  // if (displayDateInfo?.date) {
  //   const formattedDate = formatPickupDateShort(displayDateInfo.date);
  //   displayDateText = displayDateInfo.type === 'pickup' ? `ÌîΩÏóÖ ${formattedDate}` : ``;
  // }
  
  // Ï£ºÎ¨∏ÏùºÏàú ÌÉ≠Ïù¥ Ï†úÍ±∞ÎêòÏñ¥ ÌîΩÏóÖÏùº Ï†ïÎ≥¥Îäî Ïù¥Ï†ú Ìó§ÎçîÏóêÏÑú Î≥¥Ïó¨ÏßÄÎØÄÎ°ú Ïπ¥Îìú ÎÇ¥Î∂ÄÏóêÎäî Î∂àÌïÑÏöî

  return (
    <motion.div
      className={`order-card-v3 ${isSelected ? 'selected' : ''} ${cancellable ? 'cancellable' : ''} ${isEvent ? 'event-item' : ''} ${isCanceledOrNoShow ? 'canceled-order' : ''}`}
      layoutId={item.stableId}
      key={item.id}
      onClick={handleClick} // ‚úÖ onClickÏúºÎ°ú Î≥ÄÍ≤Ω
      whileTap={cancellable && !isCanceledOrNoShow ? { scale: 0.98 } : {}}
      transition={{ duration: 0.2, ease: "easeInOut" }}
    >
      <div className="card-v3-body">
        <div className="item-image-wrapper">
          <SafeThumb
            src={item.imageUrl || (isEvent ? DEFAULT_EVENT_IMAGE : undefined)}
            alt={item.productName}
            className="item-image"
          />
        </div>
        <div className="item-aggregated-info">
          <div className="info-top-row">
            <span className="product-name-top">{topText}</span>
            <div className="status-and-event-wrapper">
              {isEvent && <span className="event-badge">Ïù¥Î≤§Ìä∏</span>}
              <span className={`status-badge ${statusClass}`}>
                <StatusIcon size={14} /> {statusText}
              </span>
            </div>
          </div>
          <div className="info-bottom-row">
            <span className="item-options-quantity">
              <span className="item-option-name">{bottomText}</span>
              {!isQuantityEditable && <span className="item-quantity">({item.totalQuantity}Í∞ú)</span>}
            </span>
            
            {isQuantityEditable ? (
              <div className="quantity-control-container" onClick={(e) => e.stopPropagation()}>
                <QuantityControls
                  value={item.totalQuantity}
                  onUpdate={(newQuantity) => onQuantityUpdate(item.originalOrders[0].id, newQuantity)}
                  orderId={item.originalOrders[0].id}
                  max={maxQuantity}
                  onStockLimitDiscovered={onStockLimitDiscovered}
                />
              </div>
            ) : (
              // displayDateText && <span className="date-info-badge">{displayDateText}</span>
              // ÌîΩÏóÖÏùºÏàúÏúºÎ°ú ÌÜµÏùºÎêòÏñ¥ Ïπ¥Îìú ÎÇ¥Î∂ÄÏùò ÎÇ†Ïßú Ï†ïÎ≥¥Îäî Ï†úÍ±∞
              null
            )}
          </div>
        </div>
      </div>
    </motion.div>
  );
});

const WaitlistItemCard: React.FC<{ 
  item: WaitlistInfo; 
  isSelected: boolean; 
  onSelect: (id: string) => void; 
}> = React.memo(({ item, isSelected, onSelect }) => {
  const stableId = useMemo(() => item.timestamp.toMillis().toString(), [item.timestamp]);
  
  const handleSelect = useCallback((e: React.MouseEvent) => {
    e.preventDefault(); // ÎìúÎûòÍ∑∏ ÌõÑ ÌÅ¥Î¶≠ Ïò§Ïù∏ Î∞©ÏßÄÎ•º ÏúÑÌï¥
    onSelect(stableId);
  }, [stableId, onSelect]);

  // useLongPress Ï†úÍ±∞
  // const handlers = useLongPress(() => {}, handleSelect, { initialDelay: 500 });

  return (
    <motion.div 
      className={`waitlist-card ${isSelected ? 'selected' : ''}`} 
      layout 
      onClick={handleSelect} // ‚úÖ onClickÏúºÎ°ú Î≥ÄÍ≤Ω
      whileTap={{ scale: 0.98 }} 
      transition={{ duration: 0.2, ease: "easeInOut" }}
    >
      <div className="card-v3-body">
        <div className="item-image-wrapper">
          <SafeThumb
            src={item.imageUrl || PLACEHOLDER}
            alt={item.productName}
            className="item-image"
          />
        </div>
        <div className="item-aggregated-info">
          <div className="info-top-row">
            <span className="product-name-top">{item.productName}</span>
            {item.waitlistOrder && (<span className="waitlist-order-badge"><Bolt size={14} />ÎåÄÍ∏∞ {item.waitlistOrder}Î≤à</span>)}
          </div>
          <div className="info-bottom-row">
            <span className="item-options-quantity">
              <span className="item-option-name">{item.itemName}</span>
              <span className="item-quantity">({item.quantity}Í∞ú)</span>
            </span>
          </div>
        </div>
      </div>
    </motion.div>
  );
});

// Ï∑®ÏÜå ÏöîÏ≤≠Ïóê ÎåÄÌïú ÌÉÄÏûÖÏùÑ Ï†ïÏùòÌï©ÎãàÎã§.
type CancellationRequest = {
  type: 'order' | 'waitlist';
  items: OrderCancellationItem[] | WaitlistCancellationItem[];
};

const OrderHistoryPage: React.FC = () => {
  const { user, userDocument } = useAuth();
  const { runPageTourIfFirstTime } = useTutorial();
  // ‚úÖ [ÏàòÏ†ï] viewMode Í∏∞Î≥∏Í∞íÏùÑ 'pickup'ÏúºÎ°ú Í≥†Ï†ïÌïòÍ≥† 'orders' ÏòµÏÖò Ï†úÍ±∞
  const [viewMode, setViewMode] = useState<'pickup' | 'waitlist'>('pickup'); 
  const [waitlist, setWaitlist] = useState<WaitlistInfo[]>([]);
  const [loadingWaitlist, setLoadingWaitlist] = useState(false);
  
  const [selectedOrderKeys, setSelectedOrderKeys] = useState<Set<string>>(new Set());
  const [selectedWaitlistKeys, setSelectedWaitlistKeys] = useState<Set<string>>(new Set());
  
  const [maxQuantities, setMaxQuantities] = useState<Record<string, number>>({});

  // üìå 1. Ï∑®ÏÜå ÌôïÏù∏ÏùÑ Í¥ÄÎ¶¨ÌïòÍ∏∞ ÏúÑÌïú ÏÉàÎ°úÏö¥ ÏÉÅÌÉú Ï∂îÍ∞Ä
  const [cancellationRequest, setCancellationRequest] = useState<CancellationRequest | null>(null);

  const functions = useMemo(() => getFunctions(getApp(), 'asia-northeast3'), []);
  const getUserOrdersCallable = useMemo(() => httpsCallable(functions, 'getUserOrders'), [functions]);

  // ‚úÖ [ÏàòÏ†ï] viewMode Î≥ÄÍ≤Ω Ìï®ÏàòÏóêÏÑú 'orders' Ï†úÍ±∞
  const handleViewChange = (mode: 'pickup' | 'waitlist') => {
    setViewMode(mode);
    setSelectedOrderKeys(new Set());
    setSelectedWaitlistKeys(new Set());
  };

  const basePayload = useMemo(() => {
    const payload = { userId: user?.uid };
    
    // ‚úÖ [ÏµúÏ¢Ö ÏàòÏ†ï] 'Ï£ºÎ¨∏ÏùºÏàú' Ï†úÍ±∞, 'ÌîΩÏóÖÏùºÏàú'Ïù¥ Î©îÏù∏: Í≥ºÍ±∞/ÎØ∏Îûò Î™®Îëê ÌîΩÏóÖÏùº Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
    return { 
        ...payload, 
        orderByField: 'pickupDate', 
        orderDirection: 'desc', // ÏµúÍ∑º ÌîΩÏóÖÏùºÏù¥ ÏúÑÏóê Ïò§ÎèÑÎ°ù ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
        filterStatuses: null // Î™®Îì† Ï£ºÎ¨∏ ÏÉÅÌÉúÎ•º Í∞ÄÏ†∏Ïò¥
      };
  }, [user]);

  // viewModeÎäî 'pickup'ÏúºÎ°ú Í≥†Ï†ïÌïòÍ±∞ÎÇò 'waitlist'Ïùº ÎïåÎßå isActiveÎ•º trueÎ°ú ÏÑ§Ï†ï
  const { data: orders, setData: setOrders, loading: ordersLoading, hasMore: hasMoreOrders, loadMore: loadMoreOrders } =
    usePaginatedData<Order>(user?.uid, getUserOrdersCallable, basePayload, viewMode === 'pickup'); // viewMode === 'orders' Î°úÏßÅ Ï†úÍ±∞

  useEffect(() => {
    if (userDocument) {
      runPageTourIfFirstTime('hasSeenOrderHistoryPage', orderHistoryTourSteps);
    }
  }, [userDocument, runPageTourIfFirstTime]);

  useEffect(() => {
    const fetchWaitlist = async () => {
      if (user && viewMode === 'waitlist') {
        setLoadingWaitlist(true);
        try {
          const fetchedWaitlist: WaitlistInfo[] = await getUserWaitlist(user.uid);
          
          const activeWaitlist = fetchedWaitlist.filter(item => {
            if (!item.primaryReservationEndAt) {
              console.warn('Waitlist item is missing primaryReservationEndAt:', item);
              return true;
            }
            return dayjs().isBefore(safeToDate(item.primaryReservationEndAt));
          });

          setWaitlist(activeWaitlist);

        } catch (error) {
          showToast('error', "ÎåÄÍ∏∞ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        } finally {
          setLoadingWaitlist(false);
        }
      }
    };
    fetchWaitlist();
  }, [user, viewMode]);

  const aggregatedItems = useMemo(() => {
    const aggregated: { [key: string]: AggregatedItem } = {};
    orders.forEach(order => {
      // ‚úÖ [ÏàòÏ†ï] ÌîΩÏóÖÏùº(pickupDate) Í∏∞Ï§ÄÏúºÎ°ú Í≥†Ï†ï
      const date = safeToDate(order.pickupDate);
      if (!date) return;
      (order.items || []).forEach((item: OrderItem) => {
        // Í∞Å Ï£ºÎ¨∏Ïù¥ Í≥†Ïú†Ìïú Ïπ¥ÎìúÎ°ú ÌëúÏãúÎêòÎèÑÎ°ù aggregation keyÎ•º Ï£ºÎ¨∏ ID Í∏∞Î∞òÏúºÎ°ú ÏÑ§Ï†ï
        const aggregationKey = `${order.id}-${item.itemId}`;
        const stableAnimationId = `${item.productId?.trim() ?? ''}-${item.variantGroupName?.trim() ?? ''}-${item.itemName?.trim() ?? ''}-${order.wasPrepaymentRequired}`;
        if (!aggregated[aggregationKey]) {
          aggregated[aggregationKey] = {
            id: aggregationKey,
            stableId: stableAnimationId,
            productId: item.productId,
            productName: item.productName,
            variantGroupName: item.variantGroupName,
            itemName: item.itemName,
            totalQuantity: 0,
            imageUrl: item.imageUrl,
            originalOrders: [],
            status: order.status,
            wasPrepaymentRequired: order.wasPrepaymentRequired ?? false
          };
        }
        aggregated[aggregationKey].totalQuantity += item.quantity;
        aggregated[aggregationKey].originalOrders.push(order);
      });
    });
    Object.values(aggregated).forEach(item => {
      // Ï£ºÎ¨∏ ÏÉùÏÑ±Ïùº(createdAt)Ïù¥ ÏïÑÎãàÎùº ÌîΩÏóÖÏùº(pickupDate) Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨Ìï¥Ïïº Ìï® (Îã§Ïàò Ï£ºÎ¨∏ Ï∑®Í∏â Ïãú)
      item.originalOrders.sort((a, b) => (safeToDate(b.pickupDate)?.getTime() || 0) - (safeToDate(a.pickupDate)?.getTime() || 0));
    });
    const groupedByDate: { [date: string]: AggregatedItem[] } = {};
    Object.values(aggregated).forEach(item => {
      const firstOrder = item.originalOrders[0];
      if (!firstOrder) return;
      // ‚úÖ [ÏàòÏ†ï] ÌîΩÏóÖÏùº(pickupDate) Í∏∞Ï§ÄÏúºÎ°ú Í≥†Ï†ï
      const date = safeToDate(firstOrder.pickupDate);
      if (!date) return;
      const dateStr = dayjs(date).format('YYYY-MM-DD');
      if (!groupedByDate[dateStr]) groupedByDate[dateStr] = [];
      // AggregatedItemCardÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥Î•º Ï∂îÍ∞ÄÏ†ÅÏúºÎ°ú Ï†ïÎ†¨ÌïòÎäî Î°úÏßÅÏùÄ Ïó¨Í∏∞ÏÑúÎäî ÏÉùÎûµ
      groupedByDate[dateStr].push(item);
    });
    return groupedByDate;
    // viewModeÎäî 'pickup'ÏúºÎ°ú Í≥†Ï†ïÎêòÏóàÏúºÎØÄÎ°ú ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ÏóêÏÑú Ï†úÍ±∞
  }, [orders]);

  const handleScroll = useCallback(() => {
    const isAtBottom = window.innerHeight + document.documentElement.scrollTop >= document.documentElement.offsetHeight - 200;
    // ‚úÖ [ÏàòÏ†ï] viewMode === 'orders' Î°úÏßÅ Ï†úÍ±∞
    if (isAtBottom && viewMode === 'pickup' && !ordersLoading && hasMoreOrders) {
      loadMoreOrders();
    }
  }, [viewMode, ordersLoading, hasMoreOrders, loadMoreOrders]);

  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  const handleItemSelect = useCallback((itemKey: string, type: 'order' | 'waitlist') => {
    const setter = type === 'order' ? setSelectedOrderKeys : setSelectedWaitlistKeys;
    setter(prev => {
        const newSet = new Set(prev);
        if (newSet.has(itemKey)) newSet.delete(itemKey);
        else newSet.add(itemKey);
        return newSet;
    });
  }, []);

  const handleQuantityUpdate = useCallback((orderId: string, newQuantity: number) => {
    setOrders(prevOrders => prevOrders.map(order => {
        if (order.id === orderId) {
            const updatedItem = { ...order.items[0], quantity: newQuantity };
            return {
                ...order,
                items: [updatedItem],
                totalPrice: updatedItem.unitPrice * newQuantity,
            };
        }
        return order;
    }));
  }, [setOrders]);
  
  const handleStockLimitDiscovered = useCallback((orderId: string, max: number) => {
    setMaxQuantities(prev => ({ ...prev, [orderId]: max }));
  }, []);

  // üìå 2. Ïã§Ï†ú Ï∑®ÏÜåÎ•º Ïã§ÌñâÌïòÎäî Ìï®ÏàòÎ•º Î∂ÑÎ¶¨
  const executeCancellation = useCallback((request: CancellationRequest) => {
    const { type, items } = request;

    if (type === 'order') {
        const ordersToCancel = items as OrderCancellationItem[];
        const cancelPromises = ordersToCancel.map(item =>
            cancelOrder(item.order.id, { penaltyType: item.isPenalty ? 'late' : 'none' })
                .then(() => ({ status: 'fulfilled' as const, value: item }))
                .catch(error => ({ status: 'rejected' as const, reason: error, item }))
        );

        showPromiseToast(Promise.all(cancelPromises), {
            loading: `${ordersToCancel.length}Í∞ú Ìï≠Î™© Ï∑®ÏÜå Ï§ë...`,
            success: (results) => {
                const successfulCancellations = results
                    .filter((r): r is { status: 'fulfilled'; value: OrderCancellationItem } => r.status === 'fulfilled')
                    .map(r => r.value);

                const failedCancellations = results
                    .filter((r): r is { status: 'rejected'; reason: any; item: OrderCancellationItem } => r.status === 'rejected');

                if (successfulCancellations.length > 0) {
                    const canceledOrderIds = new Set(successfulCancellations.map(i => i.order.id));
                    setOrders(prev => prev.map(o => {
                        if (canceledOrderIds.has(o.id)) {
                            const canceledItemInfo = successfulCancellations.find(i => i.order.id === o.id);
                            const newStatus: OrderStatus = canceledItemInfo?.isPenalty ? 'LATE_CANCELED' : 'CANCELED';
                            return { ...o, status: newStatus };
                        }
                        return o;
                    }));
                    setSelectedOrderKeys(new Set());
                }

                if (failedCancellations.length > 0) {
                    console.error('Order cancellation failures:', failedCancellations.map(f => ({ reason: f.reason, orderId: f.item.order.id })));
                    return `${successfulCancellations.length}Í∞ú Ï∑®ÏÜå ÏÑ±Í≥µ, ${failedCancellations.length}Í∞ú Ïã§Ìå®.`;
                }

                return `${successfulCancellations.length}Í∞ú Ìï≠Î™©Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.`;
            },
            error: (err) => {
                console.error("Unexpected error during bulk order cancel:", err);
                return 'ÏùºÎ∂Ä Ìï≠Î™© Ï∑®ÏÜå Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
            }
        });

    } else { // waitlist
        if (!user) return;
        const itemsToCancel = items as WaitlistCancellationItem[];
        const cancelPromises = itemsToCancel.map(item =>
            cancelWaitlistEntry(item.productId, item.roundId, user.uid, item.itemId)
                .then(() => ({ status: 'fulfilled' as const, value: item }))
                .catch(error => ({ status: 'rejected' as const, reason: error, item }))
        );

        showPromiseToast(Promise.all(cancelPromises), {
            loading: `${itemsToCancel.length}Í∞ú Ìï≠Î™© Ï∑®ÏÜå Ï§ë...`,
            success: (results) => {
                const successfulCancellations = results
                    .filter((r): r is { status: 'fulfilled', value: WaitlistInfo } => r.status === 'fulfilled')
                    .map(r => r.value);
                
                const failedCancellations = results
                    .filter((r): r is { status: 'rejected', reason: any, item: WaitlistInfo } => r.status === 'rejected');

                if (successfulCancellations.length > 0) {
                    const canceledKeys = new Set(successfulCancellations.map(i => i.timestamp.toMillis().toString()));
                    setWaitlist(prev => prev.filter(w => !canceledKeys.has(w.timestamp.toMillis().toString())));
                    setSelectedWaitlistKeys(new Set());
                }

                if (failedCancellations.length > 0) {
                    console.error("Waitlist cancellation failures:", failedCancellations.map(f => ({ reason: f.reason, item: f.item })));
                    return `${successfulCancellations.length}Í∞ú ÏÑ±Í≥µ, ${failedCancellations.length}Í∞ú Ïã§Ìå®.`;
                }

                return `${successfulCancellations.length}Í∞ú ÎåÄÍ∏∞ Ïã†Ï≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.`;
            },
            error: () => 'ÎåÄÍ∏∞ Ï∑®ÏÜå Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
        });
    }
  }, [user, setOrders, setWaitlist]);


  // üìå 3. Ï∑®ÏÜå 'ÏöîÏ≤≠'ÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò (ÏÉÅÌÉúÎßå Î≥ÄÍ≤Ω)
  const handleBulkCancelRequest = useCallback((type: 'order' | 'waitlist') => {
    if (type === 'order') {
        const allAggregatedItems = Object.values(aggregatedItems).flat();
        const ordersToCancel: OrderCancellationItem[] = [];
        selectedOrderKeys.forEach(key => {
            const aggItem = allAggregatedItems.find(item => item.id === key);
            if (aggItem) {
                const { cancellable, orderToCancel, isPenaltyPeriod } = getCancellationDetails(aggItem);
                if (cancellable && orderToCancel) {
                    ordersToCancel.push({ order: orderToCancel, isPenalty: isPenaltyPeriod });
                }
            }
        });

        if (ordersToCancel.length === 0) {
            showToast('info', 'Ï∑®ÏÜåÌï† Ïàò ÏûàÎäî Ìï≠Î™©Ïù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
            return;
        }
        setCancellationRequest({ type: 'order', items: ordersToCancel });
    } else { // waitlist
        const itemsToCancel: WaitlistCancellationItem[] = [];
        selectedWaitlistKeys.forEach(key => {
            const waitlistItem = waitlist.find(item => item.timestamp.toMillis().toString() === key);
            if (waitlistItem) itemsToCancel.push(waitlistItem);
        });

        if (itemsToCancel.length === 0) {
            showToast('info', 'Ï∑®ÏÜåÌï† ÎåÄÍ∏∞ Ìï≠Î™©Ïù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
            return;
        }
        setCancellationRequest({ type: 'waitlist', items: itemsToCancel });
    }
  }, [aggregatedItems, selectedOrderKeys, selectedWaitlistKeys, waitlist]);


  // üìå 4. cancellationRequest ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎêòÎ©¥ ÌôïÏù∏ ÌÜ†Ïä§Ìä∏Î•º ÎùÑÏö∞Îäî useEffect
  useEffect(() => {
    if (!cancellationRequest) {
        return;
    }

    const { type, items } = cancellationRequest;
    const toastId = `bulk-cancel-confirmation-${type}`;
    let title = '';
    let message = '';

    if (type === 'order') {
        const containsPenalty = (items as OrderCancellationItem[]).some(i => i.isPenalty);
        title = containsPenalty ? "üö® ÌéòÎÑêÌã∞ Ìè¨Ìï®Îêú Ï∑®ÏÜå" : "ÏÑ†ÌÉù Ìï≠Î™© Ï∑®ÏÜå";
        message = `ÏÑ†ÌÉùÌïú ${items.length}Í∞úÏùò ÏòàÏïΩÏùÑ Ï†ïÎßê Ï∑®ÏÜåÌïòÏãúÍ≤†ÏäµÎãàÍπå?` + 
                  (containsPenalty ? "\n'ÎÖ∏Ïáº' Ï≤òÎ¶¨ÎêòÎäî Ìï≠Î™©Ïù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§." : "");
    } else {
        title = "ÎåÄÍ∏∞ Ï∑®ÏÜå";
        message = `ÏÑ†ÌÉùÌïú ${items.length}Í∞úÏùò ÎåÄÍ∏∞ Ïã†Ï≤≠ÏùÑ Ï∑®ÏÜåÌïòÏãúÍ≤†ÏäµÎãàÍπå?`;
    }

    toast((t) => (
        <div className="confirmation-toast-content">
            <AlertCircle size={44} className="toast-icon" style={{ color: 'var(--danger-color, #ef4444)' }} />
            <h4>{title}</h4>
            <p style={{ whiteSpace: 'pre-line' }}>{message}</p>
            <div className="toast-buttons">
                <button className="common-button button-secondary button-medium" onClick={() => {
                    toast.dismiss(t.id);
                    setCancellationRequest(null); // 'Ïú†ÏßÄ' Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
                }}>Ïú†ÏßÄ</button>
                <button className="common-button button-danger button-medium" onClick={() => {
                    toast.dismiss(t.id);
                    executeCancellation(cancellationRequest); // Ïã§Ìñâ Ìï®Ïàò Ìò∏Ï∂ú
                }}>Î™®Îëê Ï∑®ÏÜå</button>
            </div>
        </div>
    ), { 
        id: toastId, 
        duration: Infinity, 
        style: { background: 'transparent', boxShadow: 'none', border: 'none', padding: 0 } 
    });
    
    // üí° [Ïò§Î•ò ÏàòÏ†ï] 622Î≤àÏß∏ Ï§Ñ Í∑ºÏ≤òÏùò Î∂àÌïÑÏöîÌïú return Î∏îÎ°ù Ï†úÍ±∞
  }, [cancellationRequest, executeCancellation]);

  const renderOrderContent = () => {
    const isFirstLoading = ordersLoading && orders.length === 0;
    if (isFirstLoading) { return <div className="loading-spinner-container"><InlineSodomallLoader /></div>; }

    const ordersExist = orders.length > 0;
    if (!ordersExist && !ordersLoading) { return <EmptyHistory type='pickup' />; } // ‚úÖ type='pickup'ÏúºÎ°ú Í≥†Ï†ï

    // ‚úÖ [ÏàòÏ†ï] Ï†ïÎ†¨: ÌîΩÏóÖÏùº(YYYY-MM-DD) Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î¶ºÏ∞®Ïàú(ÏµúÏã† ÌîΩÏóÖÏùºÏù¥ ÏúÑÎ°ú)
    const sortedDates = Object.keys(aggregatedItems).sort((a, b) => new Date(b).getTime() - new Date(a).getTime());


    return (
      <div className="orders-list">
        <AnimatePresence>
          {sortedDates.map((dateStr, index) => {
            if (aggregatedItems[dateStr].length === 0) return null;
            return (
              <motion.div key={dateStr} layout>
                <div className="date-header-container">
                  {/* ‚úÖ [ÏàòÏ†ï] viewModeÎ•º DateHeaderÏóê Ï†ÑÎã¨ÌïòÏó¨ 'ÌîΩÏóÖÏÉÅÌíà' Ìó§Îçî Ìè¨Îß∑ ÏÇ¨Ïö© */}
                  <DateHeader date={new Date(dateStr)} viewMode="pickup" />
                  {index === 0 && (
                    <div className="cancel-instruction" data-tutorial-id="history-cancel-info">
                      <Info size={14} /><span>Ïπ¥ÎìúÎ•º ÌÅ¥Î¶≠ÌïòÏó¨ Ï∑®ÏÜåÌï† Ìï≠Î™©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</span>
                    </div>
                  )}
                </div>
                <div className="order-cards-grid">
                  {aggregatedItems[dateStr].map(item => {
                    // ÌîΩÏóÖÏùºÏàúÏúºÎ°ú Í≥†Ï†ïÎêòÏóàÏúºÎØÄÎ°ú displayDateInfoÎäî AggregatedItemCard ÎÇ¥Î∂ÄÏóêÏÑú ÌïÑÏöî ÏóÜÏùå.
                    return (
                      <AggregatedItemCard
                        key={item.id}
                        item={item}
                        isSelected={selectedOrderKeys.has(item.id)}
                        onSelect={(id) => handleItemSelect(id, 'order')}
                        // displayDateInfo props Ï†úÍ±∞
                        onQuantityUpdate={handleQuantityUpdate}
                        maxQuantity={maxQuantities[item.originalOrders[0]?.id]}
                        onStockLimitDiscovered={handleStockLimitDiscovered}
                      />
                    );
                  })}
                </div>
              </motion.div>
            )
          })}
        </AnimatePresence>
      </div>
    );
  };

  const renderWaitlistContent = () => {
    if (loadingWaitlist) { return <div className="loading-spinner-container"><InlineSodomallLoader /></div>; }
    if (waitlist.length === 0 && !loadingWaitlist) { return <EmptyHistory type="waitlist" />; }
    return (
      <div className="waitlist-list">
         <div className="date-header-container">
            <h2 className="date-header">ÎÇòÏùò ÎåÄÍ∏∞ Î™©Î°ù</h2>
            <div className="cancel-instruction" data-tutorial-id="history-cancel-info">
                <Info size={14} /><span>Ïπ¥ÎìúÎ•º ÌÅ¥Î¶≠ÌïòÏó¨ Ï∑®ÏÜåÌï† Ìï≠Î™©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</span>
            </div>
        </div>
        <AnimatePresence>
          {waitlist.map(item => (
            <WaitlistItemCard
              key={`${item.roundId}-${item.itemId}-${item.timestamp.toMillis()}`}
              item={item}
              isSelected={selectedWaitlistKeys.has(item.timestamp.toMillis().toString())}
              onSelect={(id) => handleItemSelect(id, 'waitlist')}
            />
          ))}
        </AnimatePresence>
      </div>
    );
  };

  return (
    <div className="customer-page-container">
      <div className="order-history-page">
        <div className="view-toggle-container" data-tutorial-id="history-view-toggle">
          {/* ‚úÖ [ÏàòÏ†ï] Ï£ºÎ¨∏ÏùºÏàú ÌÉ≠ Ï†úÍ±∞, ÌîΩÏóÖ ÏòàÏïΩ ÎÇ¥Ïó≠ ÌÉ≠ÏùÑ Í∏∞Î≥∏ ÌôúÏÑ±Ìôî ÏÉÅÌÉúÎ°ú Ïú†ÏßÄ */}
          <button className={`toggle-btn ${viewMode === 'pickup' ? 'active' : ''}`} onClick={() => handleViewChange('pickup')}> <Truck size={18} /> ÌîΩÏóÖ ÏòàÏïΩ ÎÇ¥Ïó≠ </button>
          <button className={`toggle-btn ${viewMode === 'waitlist' ? 'active' : ''}`} onClick={() => handleViewChange('waitlist')}> <Hourglass size={18} /> ÎåÄÍ∏∞Î™©Î°ù </button>
        </div>
        
        <AnimatePresence mode="wait">
          <motion.div key={viewMode} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }} >
            {viewMode === 'waitlist' ? renderWaitlistContent() : renderOrderContent()}
          </motion.div>
        </AnimatePresence>
        {/* ‚úÖ [ÏàòÏ†ï] viewMode === 'orders' Î°úÏßÅ Ï†úÍ±∞ */}
        {viewMode === 'pickup' && ordersLoading && orders.length > 0 && (<div className="loading-more-spinner"><InlineSodomallLoader /></div>)}
        {viewMode === 'pickup' && !hasMoreOrders && orders.length > 0 && (<div className="end-of-list-message">Î™®Îì† ÎÇ¥Ïó≠ÏùÑ Î∂àÎü¨ÏôîÏäµÎãàÎã§.</div>)}
        
        <AnimatePresence>
          {((viewMode === 'pickup' && selectedOrderKeys.size > 0) ||
           (viewMode === 'waitlist' && selectedWaitlistKeys.size > 0)) && (
            <motion.div
              className="fab-container"
              initial={{ y: 100, opacity: 0, scale: 0.8 }}
              animate={{ y: 0, opacity: 1, scale: 1 }}
              exit={{ y: 100, opacity: 0, scale: 0.8 }}
              transition={{ type: 'spring', stiffness: 200, damping: 25 }}
            >
              <button 
                className="fab-cancel-btn" 
                onClick={() => handleBulkCancelRequest(viewMode === 'waitlist' ? 'waitlist' : 'order')}
              >
                <XCircle size={20} />
                <span>
                  {viewMode === 'waitlist' 
                    ? `${selectedWaitlistKeys.size}Í∞ú ÎåÄÍ∏∞ Ï∑®ÏÜå` 
                    : `${selectedOrderKeys.size}Í∞ú ÏòàÏïΩ Ï∑®ÏÜå`}
                </span>
              </button>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default OrderHistoryPage;