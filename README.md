# 🛍️ 소도몰 프로젝트

이 문서는 '소도몰' 프로젝트의 구조와 주요 코드의 역할을 정리하기 위해 작성되었습니다.

## 🚀 프로젝트 소개

-   **목표:** React와 Firebase를 사용하여 간단한 상품 쇼핑몰 웹사이트를 구축합니다.
-   **주요 기능:** 회원가입, 로그인, 상품 목록 보기, 상품 상세 정보 보기, 관리자 페이지 등

## 🛠️ 사용된 기술 스택

-   **프론트엔드:** React, TypeScript, Vite
-   **백엔드 & 데이터베이스:** Firebase (Firestore, Authentication, Storage)
    -   **Firebase Extensions (Resize Images):** 이미지 업로드 시 WebP 형식 변환 및 리사이징 자동화
-   **스타일링:** 일반 CSS (.css)
-   **UI & 상태관리:**
    -   `react-hot-toast`: 사용자 피드백을 위한 세련된 알림(Toast) 메시지
    -   `lucide-react`: 경량 SVG 아이콘 라이브러리
    -   `date-fns`: 날짜 및 시간 처리 유틸리티 (dayjs 대신 사용)
-   **전역 상태 관리**: React Context API (`useAuth`, `useCart` 등 커스텀 훅 활용)
-   **유틸리티:**
    -   `lodash.isequal`: 객체 및 배열의 깊은 비교를 통한 불필요한 리렌더링 방지
    -   `zod`: 데이터 유효성 검사를 통한 런타임 안정성 강화
-   **배포:** Vercel

## 📁 디렉토리(폴더) 구조 설명

프로젝트의 주요 폴더와 파일 역할은 다음과 같습니다.

SODOMALL-APP/
├── public/              # 이미지, 폰트 등 정적 파일 보관
├── scripts/             # 프로젝트 관련 보조 스크립트 파일 보관
├── src/                 # ✅ 핵심 소스 코드가 있는 폴더
│   ├── assets/          # 로고, 아이콘 등 작은 이미지 파일 보관
│   ├── components/      # 여러 곳에서 재사용되는 UI 컴포넌트를 보관하며, 역할에 따라 admin/, customer/ 등으로 하위 폴더를 구성
│   ├── context/         # 앱 전역 상태 관리를 위한 Context API 파일들 (인증, 장바구니 등)
│   ├── firebase/        # Firebase 초기 설정 및 기능별 서비스 함수 모음
│   ├── hooks/           # 커스텀 훅 (예: useHorizontalScroll) 보관
│   ├── layouts/         # 페이지들의 공통적인 뼈대(헤더, 푸터 등)을 정의
│   ├── pages/           # 웹사이트의 각 페이지 단위 컴포넌트
│   │   ├── admin/       # 관리자 관련 페이지
│   │   └── customer/    # 고객 관련 페이지
│   ├── styles/          # 전역적으로 사용되는 CSS 스타일 파일 보관
│   ├── types/           # 전역 TypeScript 타입 정의 파일 (react-html.d.ts 등)
│   └── utils/           # 공통 유틸리티 함수 보관 (예: 이미지 URL 변환)
├── .env                 # API 키 등 민감한 정보 보관 (Git에 올리면 안 됨)
├── firebase.json        # Firebase 호스팅, Firestore 규칙 등 설정
├── index.html           # 앱의 진입점이 되는 메인 HTML 파일
├── package.json         # 프로젝트 정보 및 의존성 라이브러리 목록
├── README.md            # 바로 이 파일! 프로젝트 설명서
├── tsconfig.app.json    # Vite 앱을 위한 상세 TypeScript 설정 (경로 별칭 '@' 포함)
└── vite.config.ts       # Vite 빌드 도구 설정

## 📄 주요 파일 상세 설명

### `src/main.tsx`

-   React 애플리케이션의 **최초 진입점(Entry Point)**입니다.
-   `index.html` 파일의 'root' div를 찾아, 그 안에 메인 컴포넌트인 `<App />`을 렌더링(표시)하는 역할을 합니다.
-   `<StrictMode>`로 앱을 감싸서 개발 중 잠재적인 문제를 미리 감지하도록 돕습니다.

### `src/firebase/폴더`

Firebase와의 모든 통신을 담당하는 중앙 허브 역할을 하는 폴더입니다.
`firebaseConfig.ts`: Firebase 초기 설정 코드가 포함되어 있습니다.
기능별 서비스 파일: Firestore 데이터베이스와의 통신을 기능별로 분리하여 관리합니다.
`productService.ts`: 상품 정보(생성, 수정, 조회, 대기자 등록) 관련 함수를 관리합니다.
`orderService.ts`: 결제 완료된 '주문' 내역을 관리합니다. **또한, cancelOrder 함수에는 서버사이드 유효성 검사 로직이 추가되어 프론트엔드와 동일한 취소 정책을 서버에서도 이중으로 검증하여, 데이터 정합성과 보안을 강화합니다.**
`cartService.ts`: (신규) 장바구니 관련 로직, 특히 실시간 재고 확인 후 담기와 같은 기능을 전담합니다.
`generalService.ts`: 배너, 카테고리 등 여러 곳에서 사용되는 공통 기능을 관리합니다.
다른 컴포넌트에서는 이 폴더의 각 서비스 파일에 정의된 함수를 import하여 사용함으로써 코드의 일관성과 재사용성을 높입니다.

### `src/App.tsx`

-   전체 애플리케이션의 **최상위 뼈대**를 구성하는 컴포넌트입니다.
-   **React Router**를 설정하여 URL 경로에 따라 다른 페이지 컴포넌트를 보여주는 라우팅을 담당합니다.
-   **모든 Context Provider**들(`AuthProvider`, `CartProvider` 등)이 이곳에서 앱 전체를 감싸, 하위 모든 컴포넌트가 전역 데이터에 접근할 수 있도록 합니다.
-   **`<Toaster />` 컴포넌트**가 위치하여, 앱 전역에서 `react-hot-toast` 알림을 사용할 수 있게 해줍니다.
-   `React.lazy`와 `Suspense`를 사용하여 페이지 로딩 시 **공용 `LoadingSpinner`**를 보여줌으로써 일관된 사용자 경험을 제공합니다.

### `src/layouts/CustomerLayout.tsx`

-   로그인한 고객이 보게 되는 모든 페이지의 **공통적인 뼈대(Layout)** 역할을 합니다.
-   화면 상단의 `<Header />`와 하단의 `<BottomNav />`가 이 컴포넌트에 포함되어 항상 표시됩니다.
-   **React Router의 모달 라우팅 로직을 처리하는 핵심 허브**입니다. `useLocation`의 `state`를 감지하여, 목록 페이지는 뒤에 그대로 유지한 채 `ProductDetailPage`를 모달로 띄우는 역할을 담당합니다.
-   모달이 열렸을 때 백그라운드 페이지의 스크롤을 막는 전역 스타일(`body`의 `overflow`)을 `useLayoutEffect`를 통해 직접 제어합니다.

### `src/pages/customer/ProductListPage.tsx`

고객용 앱의 메인 페이지에 해당하는, 가장 핵심적인 페이지 컴포넌트 중 하나입니다.
Firebase로부터 배너와 전체 상품 목록 데이터를 비동기적으로 불러옵니다.
불러온 상품들을 '오늘의 공동구매', '마감 임박', '지난 공동구매' 등 여러 섹션으로 나눕니다.
(개선) '오늘의 공동구매' 상품을 정렬하는 로직이 고도화되었습니다.
구매 가능한 상품을 왼쪽에, '대기' 상태인 품절 상품을 오른쪽에 배치합니다.
구매 가능한 상품 내에서는 한정 수량이 적은 순서대로, 수량이 같다면 가격이 높은 순서대로 정렬합니다.
사용자가 상품 수량을 조절하고, 장바구니에 담는 등 다양한 상호작용을 처리하는 로직이 포함되어 있습니다.

### `src/pages/customer/ProductDetailPage.tsx`

-   상품의 **상세 정보**를 보여주는 모달 형태의 페이지 컴포넌트입니다.
-   `getOptimizedImageUrl` 유틸리티 함수를 사용하여 **최적화된 상세 이미지(1080x1080.webp)**를 로딩합니다.
-   **데이터 하위 호환성**을 지원합니다. `salesHistory` 기반의 신규 데이터 구조와 과거의 단일 판매 데이터 구조를 모두 자동으로 감지하고 처리하여, 어떤 데이터가 오든 에러 없이 상세 페이지를 렌더링합니다.
-   **개선된 UX**: 로딩 시에는 **스켈레톤 UI**를, 옵션 변경 시에는 **토스트 알림**을 제공합니다. '재고 무제한'과 같은 정보를 명확히 표시하여 사용자 경험을 향상시켰습니다.
-   **정교화된 구매 로직**: 상품의 상태('판매 중', '품절' 등)와 **시간(마감일 이전/이후)**을 모두 고려하여, '장바구니 담기', **'대기 신청'**, 또는 '앵콜 요청' 버튼을 사용자에게 가장 적합한 시점에 동적으로 정확하게 표시합니다.
-   **개선된 UI/UX**: 하단 구매 영역을 화면 맨 아래에 고정시키고, **`useLongPress` 훅**을 활용하여 수량 버튼을 길게 누르면 연속으로 숫자가 변경되는 등 사용자 편의성을 높였습니다.

### `src/pages/customer/OrderHistoryPage.tsx`

-   **지능형 예약 내역 관리의 중심지**: 고객의 모든 주문 내역을 효과적으로 조회하고 관리하기 위한 핵심 페이지입니다.
-   **두 가지 보기 모드 제공**: '예약 건별 보기'는 사용자의 개별 주문 내역을 주문 단위로 그룹화하여 보여줍니다. '픽업일 순 보기'는 여러 주문에 흩어져 있는 동일한 상품을 픽업일에 따라 자동 합산하여, "다음에 무엇을 총 몇 개 찾아가야 하는가"를 직관적으로 알려줍니다.
-   **정교한 예약 취소 정책 구현**: 상품의 한정/무제한 여부와 실시간 상황(마감일 임박 여부)을 기준으로 '자유 취소', '신중 취소', '취소 불가' 상태를 동적으로 결정합니다.
-   **사용자 경험을 고려한 피드백**: `toast.promise`를 활용하여 주문 취소 요청과 같은 비동기 처리 과정을 로딩, 성공, 실패 알림으로 명확하게 피드백합니다. 또한, 취소 성공 시 페이지를 새로고침하지 않고 즉시 UI를 업데이트하여 부드러운 사용자 경험을 제공합니다.
-   `useMemo`를 활용해 복잡한 주문 데이터를 '픽업 상품' 기준으로 재가공하고 집계하는 로직을 관리합니다. `handleCancelOrder` 함수를 통해 실제 서비스 로직과 UI 피드백을 연동합니다.

### `src/pages/admin/DashboardPage.tsx`

-   **통합 판매 현황 대시보드**로, 관리자 페이지의 핵심 허브 역할을 합니다.
-   **'하위 상품 그룹'(`VariantGroup`) 단위**로 데이터를 집계하여, 재고를 공유하는 여러 옵션(예: 낱개, 묶음)을 하나의 행으로 묶어 보여줌으로써 재고 관리의 정확성을 높였습니다.
-   **'업로드 날짜'**를 기준으로 상품 그룹을 다시 묶어, 시간 순서에 따라 판매 현황을 직관적으로 파악할 수 있도록 돕습니다.
-   각 그룹별로 `예약 수량`, `대기 수량`, `남은 수량`, `설정된 재고` 등 핵심 지표를 한눈에 보여주며, '최종 재고 입력' 기능을 통해 1차 마감 후 발주 및 2차 판매로 이어지는 복합적인 판매 워크플로우를 지원합니다.

### `src/pages/admin/ProductListPageAdmin.tsx`

-   **대표 상품 목록을 관리**하는 핵심 관리자 페이지입니다.
-   각 상품의 **가장 최신 판매 회차**의 상태, 가격 등 요약 정보를 테이블 형태로 표시합니다.
-   **'새 회차 추가'**, '판매 이력 보기', '대표 정보 수정' 등 상품과 관련된 모든 관리 기능의 진입점 역할을 수행합니다.
-   검색, 카테고리 필터, 판매 상태 필터, 정렬 등 다양한 편의 기능을 통해 원하는 상품을 쉽게 찾을 수 있도록 돕습니다.

### `src/pages/admin/ProductAddAdminPage.tsx`

-   URL 진입 방식에 따라 신규 상품 등록과 새 회차 추가의 두 가지 모드로 동작하는 동적인 페이지입니다.
-   최종적으로 반응형 3단 그리드 레이아웃으로 설계되어, 어떤 화면 크기에서도 최적화된 UI를 제공합니다. '대표 상품 정보', '판매 옵션', '발행 설정'의 세 가지 핵심 섹션으로 구성되어 관리자가 한눈에 모든 정보를 파악하고 입력할 수 있습니다.

### `src/pages/admin/SalesRoundEditPage.tsx`

-   기존 상품의 특정 판매 회차 정보를 통합적으로 수정하는 페이지입니다.
-   `ProductAddAdminPage`와 완전히 동일한 UI/UX를 공유하여, 관리자가 일관된 경험 속에서 작업할 수 있도록 합니다.
-   상품의 대표 정보(이름, 이미지 등)와 특정 판매 회차의 상세 정보(회차명, 옵션, 기간 등)를 한 페이지에서 모두 수정하고 저장할 수 있습니다.

### `src/pages/customer/LoginPage.tsx`

-   **카카오 소셜 로그인을 처리**하는 페이지입니다.
-   Firebase의 `OAuthProvider`와 `signInWithPopup` 함수를 사용하여 로그인 로직을 수행합니다.
-   로그인 과정(진행, 성공, 실패)을 **`toast.promise`** 를 통해 사용자에게 명확하게 피드백하여 직관적인 경험을 제공합니다.

### `src/components/LoadingSpinner.tsx`

-   앱 전체에서 **일관된 로딩 UI를 제공**하기 위한 공용 컴포넌트입니다.
-   화면 전체를 덮는 반투명 오버레이와 CSS 애니메이션으로 구현된 스피너로 구성됩니다.
-   `App.tsx`나 `CustomerLayout.tsx` 등에서 `Suspense`의 `fallback`으로 사용되어 코드 중복을 방지하고 유지보수성을 높입니다.

### `src/components/customer/ProductCard.tsx`

상품 목록 페이지에 표시되는 개별 상품 카드 UI 컴포넌트입니다.
(개선) 수량 조절 기능이 대폭 향상되었습니다.
수량 표시 부분을 클릭하여 키보드로 직접 숫자를 입력할 수 있습니다.
+, - 버튼을 길게 누르면 수량이 연속으로 빠르게 변경됩니다.
(개선) '담기' 버튼을 누르면 실시간 재고를 확인하여 주문 가능 여부를 판단하고, 사용자에게 "✓ 담았어요"와 같은 명확한 시각적 피드백을 제공합니다.
상품의 재고 상태에 따라 '담기', '옵션 선택', '품절', '대기' 등 다양한 버튼을 동적으로 보여줍니다.

### `src/components/BottomNav.tsx`

-   화면 하단에 고정되어 주요 페이지로 빠르게 이동할 수 있게 해주는 **네비게이션 바 컴포넌트**입니다.
-   `NavLink`를 사용하여 현재 활성화된 메뉴를 시각적으로 표시합니다.
-   `useAuth`와 `useCart` 같은 Context를 사용하여, 관리자일 경우 '관리자' 메뉴를 추가로 보여주거나 장바구니에 담긴 상품 개수를 뱃지로 표시하는 등 동적인 UI를 제공합니다.

### `src/components/ProductSection.tsx`

-   `ProductListPage`에서 반복적으로 사용되는 **상품 목록 섹션을 담당하는 재사용 컴포넌트**입니다.
-   props로 products 배열을 직접 받는 대신, children을 받아 내부 컨텐츠를 유연하게 렌더링하는 구조로 변경되었습니다. 또한, 전용 스타일 파일(ProductSection.css)을 가져 독립성을 높였습니다.

### `src/hooks/useHorizontalScroll.ts`

-   **수평 스크롤 로직을 제공하는 커스텀 훅**입니다.
-   마우스 드래그를 통한 스크롤, 드래그 후 자연스러운 관성 스크롤 효과, 그리고 좌/우 화살표 버튼 클릭을 통한 스크롤 기능을 포함합니다.

### `src/types/react-html.d.ts`

-   TypeScript 환경에서 `<img>` 태그의 `fetchPriority`와 같은 **새로운 HTML 속성을 올바르게 인식하도록 확장**하는 타입 정의 파일입니다.
-   React의 기본 타입 정의에 포함되지 않은 웹 표준 속성을 안전하게 사용할 수 있도록 돕습니다.

### `src/utils/imageUtils.ts`

-   **이미지 관련 공통 유틸리티 함수**를 모아둔 파일입니다.
-   `getOptimizedImageUrl` 함수는 원본 이미지 URL을 받아, **Firebase Extensions (Resize Images)**를 통해 자동 생성된 **최적화된 WebP 이미지 URL로 변환**하는 핵심 역할을 수행합니다. 이를 통해 이미지 로딩 성능을 크게 향상시킵니다.

### `src/context/CartContext.tsx`

-   **'예약'과 '대기' 상태 통합 관리**: `CartItem` 타입에 `status` 필드를 추가하여, 하나의 장바구니에서 '예약'과 '대기' 상품을 모두 관리합니다. `addToCart` 함수는 두 상태의 상품이 추가될 때 수량을 합치거나 상태를 변경하는 등 복합적인 로직을 처리합니다.
-   **일괄 처리 함수 제공**: 여러 상품을 한 번에 삭제하거나 상태를 변경하는 `removeItems`, `updateItemsStatus`와 같은 함수를 추가하여, `CartPage`의 일괄 삭제 및 자동 전환 기능을 지원합니다.

### `src/firebase/orderService.ts`

-   **재고 계산 정확성 향상**: 주문 생성(`submitOrder`) 시, 트랜잭션 외부에서 현재 예약된 총수량을 먼저 계산하여 전달함으로써 재고 계산의 정확성을 크게 향상시켰습니다. 이를 통해 동시 주문 시 발생할 수 있는 재고 불일치 문제를 방지합니다.

### `src/pages/customer/CartPage.tsx`

-   **지능형 장바구니의 중심**: 고객의 예약 및 대기 상품을 모두 관리하는 핵심 페이지입니다.
-   **대기 상품 자동 처리**: 페이지에 진입하는 순간, '대기' 상태인 상품의 실시간 재고를 확인합니다. 재고가 확보되면 '예약'으로 자동 전환하고, 픽업 기한이 지난 상품은 자동 삭제하는 로직이 포함되어 있습니다.
-   **반응형 UI**: 모바일에서는 1단 목록으로, 데스크탑에서는 상품 목록과 주문 요약이 표시되는 2단 레이아웃으로 자동 전환됩니다.
-   **개선된 UX**: 상품 카드를 분리된 컴포넌트(`CartItemCard`)로 만들어 훅(Hook) 규칙 위반 오류를 해결했으며, 여러 상품을 선택하여 한 번에 삭제하는 일괄 처리 기능을 제공합니다.

### `src/components/customer/ProductCard.tsx`

-   **'대기' 기능 통합**: 품절 상품의 '대기' 버튼은 이제 `status`가 'WAITLIST'인 상품 정보를 `CartContext`에 추가하는 역할을 수행하여, 모든 장바구니 관련 로직을 일원화했습니다.
-   **수량 조절 기능 개선**: 카드 내의 수량 조절 버튼(`QuantityInput`)이 자체 로직 대신, 프로젝트 전역에서 사용하는 `useLongPress` 커스텀 훅을 사용하도록 리팩터링하여 코드 중복을 제거하고 앱 전체의 버튼 동작 경험을 통일시켰습니다.

### `src/hooks/useLongPress.ts`

-   **'짧은 클릭'과 '꾹 누르기' 동작을 모두 처리하는 커스텀 훅**입니다.
-   사용자가 버튼을 짧게 클릭했을 때와 길게 누르고 있을 때의 동작을 명확하게 구분하여, 두 이벤트가 충돌해 기능이 중복 실행되는 문제를 해결합니다. 앱 전체에서 일관된 버튼 인터랙션 경험을 제공하는 핵심적인 역할을 합니다.

## ✨ 주요 기능 동작 흐름

### 👨‍👩‍👧‍👦 고객 기능

1.  **회원 인증 (로그인/로그아웃)**
    * **동작:** 사용자가 카카오 계정으로 로그인하고, 시스템이 사용자를 인식하여 메인 페이지로 이동시키는 과정입니다. 로그인 성공/실패 시 `toast` 알림으로 사용자에게 피드백을 제공합니다.
    * **핵심 파일:** `LoginPage.tsx`, `AuthContext.tsx`, `App.tsx`

2.  **상품 목록 보기 (메인 페이지)**
    * **동작:** 로그인한 사용자가 가장 처음 보게 되는 메인 페이지가 렌더링되고, 상품 데이터가 화면에 표시되는 과정입니다.
    * (개선) 상품 목록은 사용자 경험을 고려한 정렬 기준에 따라 배치됩니다. (한정 수량 우선, 품절 상품은 후순위 배치)
    * (개선) 상품 섹션은 마우스 드래그 스크롤과 좌/우 화살표 버튼을 통해 편리하게 탐색할 수 있으며, 이 기능은 데스크탑과 모바일 모두에서 일관되게 동작합니다.
    * **핵심 파일:** `ProductListPage.tsx`, `ProductSection.tsx`, `useHorizontalScroll.ts`

3.  **상품 상세 정보 보기**
    * **동작:** 메인 페이지에서 특정 상품을 클릭했을 때, **기존 페이지의 스크롤 위치는 그대로 유지된 채** 해당 상품의 상세 정보가 담긴 모달(modal) 창이 부드럽게 나타납s. 장바구니 담기, 수량 조절 등의 상호작용 시 `toast` 알림으로 즉각적인 피드백을 제공합니다. 상품의 판매 상태에 따라 '장바구니 담기' 또는 '앵콜 요청' 버튼이 동적으로 정확하게 표시됩니다.
    * **핵심 파일:** `ProductDetailPage.tsx`, `CustomerLayout.tsx`, `ProductListPage.tsx`

4.  **장바구니 관리**
    * **동작:** 사용자가 상품을 장바구니에 담고, 확인하며, 최종적으로 예약을 확정하는 과정입니다.
    * (개선) 사용자가 '담기' 버튼을 누르는 순간, 서버의 최신 재고를 실시간으로 확인합니다. 만약 그 사이에 다른 사용자가 구매하여 재고가 부족해졌다면, "재고가 부족합니다"라는 메시지를 표시하여 동시 주문 문제를 방지합니다.
    * **핵심 파일:** `CartPage.tsx`, `ProductCard.tsx`, `cartService.ts`

5.  **대기(Waitlist) 기능**
    * **동작:** 한정 수량 상품이 모두 판매되어 품절되었을 경우, 사용자는 '대기' 버튼을 통해 상품을 장바구니의 **'대기 목록'**에 추가할 수 있습니다. 이는 별도의 시스템이 아닌, `CartItem`의 `status`가 'WAITLIST'로 설정되는 방식입니다.
    * **통합 관리**: '대기' 상품은 장바구니 페이지에 별도 섹션으로 표시되며, '예약' 상품과 마찬가지로 수량을 변경하거나 목록에서 삭제할 수 있습니다. 이를 통해 사용자는 자신의 예약 및 대기 현황을 한 곳에서 직관적으로 관리할 수 있습니다.
    * **핵심 파일:** `ProductCard.tsx`, `CartPage.tsx`, `CartContext.tsx`, `types.ts`

6.  **'앵콜' 공동구매 요청**
    * **동작:** 판매가 마감되었거나 품절된 상품에 대해 사용자가 재판매를 요청하는 기능의 동작 흐름입니다. 요청 성공/실패 여부를 `toast` 알림으로 알려줍니다.
    * **핵심 파일:** `ProductDetailPage.tsx`, `EncoreRequestContext.tsx`, `firebase.ts`

7.  **지능형 예약 내역 관리**
    * **동작:** 사용자가 마이페이지를 통해 `orders` 컬렉션에 기록된 자신의 이전 주문(예약) 내역들을 확인합니다.
    * **두 가지 보기 모드 제공**: '주문일 순 보기'는 사용자의 개별 주문 내역을 주문 단위로 그룹화하여 보여주며, '픽업일 순 보기'는 여러 주문에 흩어진 동일 상품을 픽업일에 따라 자동 합산하여 "다음에 무엇을 총 몇 개 찾아가야 하는지"를 명확히 알려줍니다.
    * **정교한 예약 취소 정책**: 상품의 한정/무제한 여부와 실시간 상황(마감일 임박 여부)을 기준으로 '자유 취소', '신중 취소', '취소 불가' 상태가 동적으로 결정됩니다.
    * **사용자 경험을 고려한 피드백**: `toast.promise`를 활용하여 주문 취소와 같은 비동기 처리 상태를 로딩, 성공, 실패 알림으로 제공합니다. 취소 성공 시에는 페이지 새로고침 없이 UI가 즉시 업데이트되어 부드러운 사용자 경험을 제공합니다.
    * **핵심 파일:** `MyPage.tsx`, `OrderHistoryPage.tsx`, `firebase.ts`

### 🔐 관리자 기능

1.  **상품 및 판매 회차 관리**
    * **동작:** **대표 상품** 단위로 상품을 관리하며, 하나의 대표 상품에 여러 **'판매 회차'**를 등록하여 판매 이력을 누적하는 기능입니다. 관리자는 대표 상품 목록에서 최신 판매 상태를 확인하고, **'새 회차 추가'**를 통해 손쉽게 재판매를 시작하거나, **'이력 보기'**로 과거 판매 내역을 확인할 수 있습니다.
    * **핵심 파일:** `ProductListPageAdmin.tsx`, `ProductAddAdminPage.tsx`, `productService.ts`

2.  **주문 관리 (상태 변경 등)**
    * **동작:** 관리자가 고객들이 예약한 주문 내역을 전체적으로 확인하고, 각 주문의 처리 상태를 변경하는 기능입니다. 주문 상태 변경 시 `toast` 알림으로 관리자에게 피드백을 제공합니다.
    * **핵심 파일:** `OrderListPage.tsx`, `firebase.ts`

3.  **배너 관리 (등록/수정/순서 변경)**
    * **동작:** 관리자가 고객용 메인 페이지 상단에 노출되는 배너를 관리하는 기능의 흐름입니다. 배너 추가/수정/삭제 시 `toast` 알림을 활용합니다.
    * **핵심 파일:** `BannerAdminPage.tsx`, `BannerForm.tsx`, `BannerList.tsx`, `firebase.ts`

4.  **카테고리 관리**
    * **동작:** 관리자가 상품을 분류하기 위한 대분류 및 하위 카테고리를 생성하고 관리하는 기능의 흐름입니다. 카테고리 추가/수정/삭제 시 `toast` 알림을 사용합니다.
    * **핵심 파일:** `CategoryManagementPage.tsx`, `firebase.ts`

5.  **통합 재고 관리 (대시보드)**
    * **동작:** 관리자가 새롭게 개편된 **'통합 판매 현황 대시보드'**를 통해 모든 상품의 재고와 주문 현황을 관리합니다. 이 대시보드는 재고를 공유하는 하위 상품 그룹(예: '레몬맛')을 하나의 단위로 묶어, '그룹 총 재고'를 기준으로 예약 수량, 남은 수량 등을 명확하게 보여줍니다. 이를 통해 '1병', '1박스' 등 여러 판매 옵션이 하나의 재고를 공유하며 차감되는 복잡한 로직을 직관적으로 관리할 수 있습니다.
    * **핵심 파일:** `DashboardPage.tsx`, `productService.ts`, `orderService.ts`

## 💡 트러블슈팅 및 개선 사항

최근 프로젝트 개선 과정에서 발생했던 주요 문제점들과 해결책을 공유합니다. 이러한 내용은 향후 개발 시 유사한 문제를 방지하고, 유지보수성을 높이는 데 기여할 것입니다.

### 1. 메인 페이지 상품 카드 UI/UX 점진적 개선 과정

-   **문제점**: 초기 상품 카드는 모든 상품(단일/복합, 한정/무제한)에 동일한 UI를 제공하여 정보가 부족했고, 공간 활용이 비효율적이었습니다. 또한, 새로운 기능(한정 수량 배너) 추가 시 전체 레이아웃이 어긋나는 문제가 발생했습니다.
-   **개선 과정**: 사용자 피드백을 바탕으로 다음과 같은 단계별 개선을 진행했습니다.
    1.  **정보 추가 및 레이아웃 재구성**:
        -   **문제**: 상품의 보관 타입(냉동/냉장 등)과 특별 라벨(인기/NEW 등)이 표시되지 않아 정보가 부족했습니다.
        -   **해결**: 카드 내부에 **보관 타입 배지**와 **특별 라벨 칩**을 추가했습니다. 더 많은 정보를 담기 위해 카드를 세로로 긴 형태로 변경하고, **`상품명/보관타입`**, **`가격/픽업일`**, **`구매 액션`** 의 명확한 3단 구조로 재배치했습니다.

    2.  **구매 경험 차별화**:
        -   **문제**: 옵션이 없는 단일 상품도 상세 페이지로 이동해야만 구매할 수 있어 비효율적이었습니다.
        -   **해결**: **단일 상품** 카드에는 **수량 조절 버튼과 '담기' 버튼을 바로 노출**시켰고, **복합 상품** 카드에는 **'옵션 선택하기 →' 버튼**을 표시하여 사용자가 명확하게 다음 행동을 인지할 수 있도록 UI를 분리했습니다.

    3.  **한정 수량 강조 및 레이아웃 정렬 문제 해결**:
        -   **문제**: 한정 수량 상품에 대한 시각적 강조가 부족했고, 이를 위해 카드 상단에 조건부 배너를 추가하자 배너가 없는 카드와 높이가 달라져 줄이 어긋나는 문제가 발생했습니다.
        -   **해결**:
            -   '진행 중' 또는 '마감 임박' 상품 중 재고가 한정된 경우, 카드 상단에 **`🔥 NN개 한정!`** 과 같은 강조 배너를 표시하도록 로직을 확장했습니다.
            -   배너 유무에 따라 카드 높이가 달라지는 문제를 해결하기 위해, 상품 목록을 감싸는 컨테이너(`product-grid.horizontal-scroll`)에 **`align-items: flex-end`** CSS 속성을 적용했습니다. 이를 통해 모든 카드가 **아래쪽 라인을 기준으로 정렬**되도록 하여, 높이가 달라도 시각적으로 안정적인 레이아웃을 구현했습니다.
            -   상단 배너와 의미가 중복되는 'LIMITED' 라벨은 카드에 표시되지 않도록 프론트엔드에서 필터링하여 정보를 간결하게 만들었습니다.

### 2. 배너 슬라이더 화살표 위치 문제 해결

-   **문제**: `BannerSlider` 컴포넌트의 네비게이션 화살표가 한쪽에만 쏠려 보이거나 제대로 표시되지 않던 문제. 초기 화면에서 왼쪽 화살표만 나타나는 경우가 있었습니다.
-   **원인**: `BannerSlider.css`에서 화살표 버튼의 `left` 또는 `right` CSS 속성이 명확하게 정의되지 않았거나, 다른 CSS 규칙에 의해 의도치 않게 재정의되었을 가능성이 있었습니다.
-   **해결**: `BannerSlider.css` 파일에서 `.banner-nav-button.prev`와 `.banner-nav-button.next`에 `left`와 `right` 속성을 명확히 지정하고, `auto`로 다른 방향의 속성을 초기화하여 양쪽 화살표가 독립적으로 위치하도록 수정했습니다.

### 3. 상품 목록 수평 스크롤 및 관성 스크롤 개선 (`ProductListPage.tsx`)

-   **문제**: `ProductListPage`에서 상품 목록이 수평으로 원활하게 스크롤되지 않거나, 드래그 후 관성 스크롤이 부자연스럽던 문제. 특정 상황에서 스크롤 화살표가 부적절하게 나타나거나 사라지는 현상이 있었습니다.
-   **원인**: `useHorizontalScroll` 훅 내부의 `setVelocity` 로직이 스크롤 속도를 너무 빠르게 설정하거나, `onMouseUp`, `onMouseLeave`에서 `setVelocity(0)`으로 관성 스크롤을 즉시 멈추도록 설정되어 있었음. 또한, 스크롤 화살표 표시 조건 (`isAtEnd`)이 너무 엄격하여 끝까지 도달해야만 사라지는 문제가 있었습니다.
-   **해결**:
    -   `onMouseMove`에서 `setVelocity` 계산 시 곱하는 값을 `0.5`에서 `0.3`으로 줄여 드래그 후 관성 스크롤 속도를 부드럽게 조정했습니다.
    -   `scrollByPage` 함수에서 스크롤 양을 `container.clientWidth * 0.8`에서 `container.clientWidth * 0.7`으로 줄여 한 번의 클릭 스크롤 이동 거리를 짧게 하여 더 자연스러운 느낌을 주었습니다.
    -   `onMouseUp` 및 `onMouseLeave`에서 `setVelocity(0)` 호출을 제거하여 드래그를 놓았을 때 관성 스크롤이 시작되도록 수정했습니다.
    -   스크롤 화살표 표시 조건 (`isAtEnd`)을 `scrollWidth - 1`에서 `scrollWidth - 5`와 같이 여유 값을 늘려 스크롤 끝 지점을 더 유연하게 감지하도록 개선했습니다.

### 4. `ProductListPage.tsx` 타입스크립트 및 데이터 로딩 로직 개선

-   **문제점**:
    -   `formatPickupDateAndDay` 함수 내 `dayNames.getDay()` 호출 오류: `dayNames`는 문자열 배열인데, `Date` 객체의 메서드인 `getDay()`를 배열에 사용하려 함.
    -   `productQuantities` 객체 접근 오류: `newQuantities.p.id` 또는 `productQuantitiesproduct.id`와 같이 객체 속성 접근 방식이 잘못됨.
    -   `MemoizedProductCard` 컴포넌트 필수 `props` 누락 오류: `onQuantityChange`, `onAddToCart`, `onCardClick` 함수들이 `MemoizedProductCard`로 전달되지 않아 발생.
    -   초기 데이터 로딩 시 Firebase 모듈 동적 import로 인한 잠재적 지연.
-   **원인**: 타입스크립트의 타입 추론 및 객체/배열 문법에 대한 오타 또는 불완전한 이해. Firebase 모듈의 지연 로딩 방식이 초기 로딩 성능에 영향을 미칠 수 있음.
-   **해결**:
    -   타입스크립트 관련 오류 해결: `formatPickupDateAndDay`에서 `dayNames[date.getDay()]`로 수정, `productQuantities[p.id]` 및 `productQuantities[product.id]`와 같이 대괄호(`[]`) 표기법 사용, 누락된 `props` 명시적 전달.
    -   **초기 로딩 시점 개선**: `useEffect` 내부에서 Firebase 모듈 동적 import를 제거하고 파일 상단에 정적으로 import 하여 번들링 최적화 및 런타임 오버헤드 감소.
    -   **상품 필터링 로직 명확화**: `useMemo` 내부의 상품 분류 로직을 더 간결하고 정확하게 수정하여, `status`, `deadlineDate`, `pickupDeadlineDate`, `stock`, `isAvailableForOnsiteSale` 등을 기반으로 `onSiteSaleProducts`, `ongoingProducts`, `additionalReservationProducts`, `pastProducts`로 정확히 분류되도록 개선했습니다.
    -   `MemoizedProductCard` 응집도 향상: 카드 내부에서 `isPurchasable` 등 필요한 모든 상태를 `product` 객체와 `now` 값을 기반으로 자체 판단하도록 변경하여 컴포넌트의 재사용성을 높였습니다.

### 5. `ProductDetailPage.tsx` 상품 상태 및 버튼 표시 로직 최종 개선

-   **문제**:
    -   '판매 중'인 상품인데도 `deadlineDate`가 지났다는 이유만으로 '앵콜 요청' 버튼이 잘못 표시되던 문제 (로그 분석을 통해 확인).
    -   '지난 공동구매' 상품들(마감/품절 상태)에서 앵콜 요청 버튼이 사라지던 문제.
    -   상품의 다양한 판매 상태(판매 중, 판매 예정, 품절, 마감, 추가 예약)에 따라 '장바구니 담기', '앵콜 요청', 또는 '판매 종료' 메시지가 정확하게 표시되지 않는 문제.
-   **원인**: `isCurrentlyPurchasable` 및 `showEncoreRequestButton`을 포함한 판매 가능 여부 판단 로직이 충분히 정교하지 못했거나, 특정 조건들이 상호 배타적이지 않아 의도치 않은 결과 발생. 특히 `deadlineDate`와 `pickupDeadlineDate`를 기준으로 하는 '추가 예약' 시나리오가 명확히 반영되지 않아, `status`가 `selling`이더라도 `deadlineDate`가 지나면 `isCurrentlyPurchasable`이 `false`가 되고 앵콜 버튼이 나타나던 현상 발생.
-   **해결**:
    -   **고객 요구 5가지 시나리오 기반 `isCurrentlyPurchasable` 로직 재정의**:
        -   **1. 공동구매 기간 안에 재고가 있음 (예약 가능)**: `product.status === 'selling'` + `now <= deadlineDate` + (재고 무제한 OR 재고 있음)
        -   **2. 공동구매 기간이 지났지만, 픽업일 전날까지 재고가 있음 (추가 예약 가능)**: `product.status === 'selling'` + `now > deadlineDate` + `now < pickupDeadlineDate` + (재고 있음)
        -   이 두 경우만 `isCurrentlyPurchasable`을 `true`로 설정하여 '장바구니 담기' 버튼이 보이도록 했습니다.
    -   **`showEncoreRequestButton` 조건 강화**: `isCurrentlyPurchasable`이 `false`일 때만 고려하며, `product.status`가 `'sold_out'` 또는 `'ended'`이거나, `deadlineDate`가 지났고 재고가 없거나(선주문 무제한 포함) 하는 등, 앵콜 요청이 합리적인 상황에서만 표시되도록 조건을 조정했습니다. 이를 통해 **마감된 상품에서 앵콜 버튼이 다시 표시**되도록 했습니다.
    -   **하단 버튼 UI 분기 명확화**: `isCurrentlyPurchasable` 여부에 따라 '장바구니 관련 UI'와 '앵콜 요청/판매 종료 메시지 UI'를 명확히 분리하여, 혼동 없이 올바른 버튼이 나타나도록 개선했습니다.
    -   `encoreCount` 업데이트 시 `updatedProductDoc.data()`를 정확히 사용하도록 오타를 수정했습니다.

### 6. `ProductAddAdminPage.tsx` 및 `ProductEditAdminPage.tsx` 상품 등록/수정 UI 및 로직 개선

-   **문제**:
    -   **가격 정책별 한정 수량 기능 부족**: 기존에는 전체 상품에 대한 총 재고만 관리하고 옵션별 재고는 관리되지 않았음.
    -   **UI 깨짐 현상 지속**: '가격 및 재고' 섹션의 입력 필드(특히 '재고갯수' 및 '단위')가 정렬되지 않거나 플레이스홀더 텍스트가 잘리는 문제.
    -   **중복 필드**: '1인당 최대 구매 수량'과 '가격 정책' 내의 '한정수량' 개념이 중복될 가능성.
-   **원인**: 복잡한 폼 요소를 `flexbox`로만 제어하려던 한계, `input` 필드의 `padding` 및 `line-height` 설정 미흡, 논리적 중복 필드 존재.
-   **해결**:
    -   **엑셀 표 형태의 Grid 레이아웃 적용**: '가격 정책' 섹션을 `display: grid`를 사용하여 엑셀 표와 유사한 컬럼 기반의 레이아웃으로 전면 개편했습니다. 이를 통해 '개당(개수)', '가격', '재고갯수', '단위', '한정수량', '제거 버튼'이 명확한 열에 정렬되도록 했습니다.
    -   **옵션별 재고(`stock`) 및 한정수량(`limitQuantity`) 관리 강화**: 각 `pricingOption`에 `stock`과 `limitQuantity` 필드를 추가하여, 옵션별로 재고를 관리하고 필요에 따라 한정 수량을 설정할 수 있도록 했습니다. `stock` 필드를 비워두면 '선예약 후발주' (무제한) 방식으로 처리됩니다.
    -   **'1인당 최대 구매 수량' 섹션 제거**: '가격 정책' 내의 '한정수량'(`limitQuantity`) 필드가 개별 옵션의 수량 제한을 담당하므로, 중복되는 기존의 '1인당 최대 구매 수량' 섹션을 제거하여 UI를 콤팩트하게 만들었습니다.
    -   **UI 요소 정렬 및 가독성 개선**: 각 입력 필드(`input`)의 `padding`, `text-align`, `height` 등을 미세 조정하여 텍스트 및 플레이스홀더가 잘리지 않고 보기 좋게 정렬되도록 했습니다. '재고갯수' 및 '한정수량' 필드의 플레이스홀더 텍스트를 제거하여 깔끔한 디자인을 유지했습니다.
    -   **CSS 최적화**: Grid 시스템 도입으로 복잡한 Flexbox 속성들을 줄이고, CSS 변수(`--spacing-xxs`, `--font-size-sm` 등)를 적극 활용하여 스타일의 일관성과 유지보수성을 높였습니다.

### 7. 관리자 대시보드 로딩 오류 및 데이터 불일치 문제 해결

-   **문제점**: 관리자 페이지의 대시보드 접근 시, 데이터 로딩이 실패하며 앱이 비정상적으로 중단되는 복합적인 오류가 발생했습니다. 콘솔에는 `TypeError`, `key` prop 관련 경고, `500 Internal Server Error` 등 다양한 오류가 동시에 나타났습니다.
-   **원인**: 디버깅을 통해 여러 단계의 원인이 중첩되어 있음을 확인했습니다.
    1.  **컴포넌트의 비정상 종료 (TypeError)**: `DailyDashboardModal` 컴포넌트가 Firestore로부터 데이터를 받지 못했을 경우(예: 색인 부재), `undefined` 상태인 배열 데이터의 `.length` 나 `.toDate()` 속성을 읽으려다 앱이 멈추는 문제였습니다.
    2.  **근본적인 데이터 조회 실패 (FirebaseError)**: Firestore 쿼리에 필요한 복합 색인(composite index)이 없어 `getDailyDashboardData` 함수가 데이터를 전혀 가져오지 못하는 것이 최초의 원인이었습니다.
    3.  **고유 `key` 값 부재 경고**: `getDailyDashboardData` 함수 내부에서 Firestore 문서 데이터를 객체로 변환할 때, 문서의 고유 ID인 `doc.id` 대신 `doc.data().id`를 사용하려 하여 `key` 값이 `undefined`로 할당되던 문제였습니다. 이로 인해 React가 목록 아이템을 제대로 식별하지 못했습니다.
    4.  **개발 서버 오류 (500 Error)**: 수정 과정에서 `useState` 구문에 오타(`= =`)가 포함되어, 개발 서버가 파일을 제대로 해석하지 못하고 `500 Internal Server Error`를 발생시키기도 했습니다.
-   **해결**:
    -   **컴포넌트 안정성 강화**: `DailyDashboardModal` 컴포넌트 내부에서 `useState`의 초기값을 빈 배열(`[]`)로 명확히 하고, `fetch` 후 상태를 업데이트할 때도 `|| []` 연산자를 사용해 항상 배열을 보장하도록 수정했습니다. 또한, 날짜 관련 데이터는 옵셔널 체이닝(`?.toDate()`)을 사용하여 데이터가 `null` 또는 `undefined`일 경우에도 앱이 멈추지 않도록 방어 코드를 추가했습니다.
    -   **Firestore 색인 생성**: 브라우저 콘솔에 출력된 `FirebaseError` 메시지의 링크를 통해 필요한 복합 색인을 생성하여 근본적인 데이터 조회 문제를 해결했습니다.
    -   **데이터 매핑 로직 수정**: `firebase.ts`의 `getDailyDashboardData` 함수에서 `map`, `forEach`를 사용할 때, 고유 ID를 `doc.id`에서 직접 가져오도록 수정하여 모든 리스트 아이템이 명확하고 고유한 `key`를 갖도록 보장했습니다.
    -   **문법 오류 수정**: `500 Error`의 원인이었던 코드 내 오타를 바로잡아 서버가 정상적으로 파일을 제공할 수 있도록 했습니다.

### 8. '판매 회차' 시스템 도입을 통한 상품 관리 아키텍처 재설계

-   **문제점**: 기존에는 동일 상품을 재판매할 때마다 상품 정보를 '복제'하여 새 상품으로 등록했습니다. 이 방식은 '카뮤트 효소' 같은 특정 상품의 누적 판매량, 가격 변동 이력, 고객의 앵콜 요청 횟수 등을 통합적으로 추적하기 어렵게 만들었습니다. 또한, 불필요한 데이터 중복이 발생하여 데이터베이스 관리가 비효율적이었습니다.
-   **원인**: `1 상품 = 1 판매` 라는 단순한 데이터 구조가 반복 판매 시나리오를 제대로 지원하지 못했습니다.
-   **해결**:
    -   **`1 대표 상품 : 多 판매 회차` 데이터 모델 도입**: Firestore의 `Product` 문서 구조를 전면 재설계했습니다. 이제 하나의 `Product` 문서는 이름, 이미지 등 변하지 않는 **고유 정보**와 함께, `salesHistory` 라는 배열 필드에 회차별 판매 정보(가격, 재고, 기간, 옵션 등)를 담은 **`SalesRound` 객체**를 누적하여 저장합니다.
    -   **관리자 UI/UX 개편**:
        -   `ProductListPageAdmin`은 이제 **대표 상품 중심**으로 목록을 보여주며, 각 상품의 최신 회차 상태를 요약하여 표시합니다.
        -   `ProductAddAdminPage`는 **'신규 상품 등록'**과 **'새 회차 추가'**의 두 가지 모드로 동작하도록 개편하여, 관리자가 의도에 맞게 데이터를 추가할 수 있도록 유도합니다.
    -   **기대 효과**: 데이터의 파편화를 막고, 특정 상품의 전체 생명주기를 한눈에 파악할 수 있게 되었습니다. 이를 통해 재고 관리의 정확성을 높이고, 과거 판매 데이터를 기반으로 한 마케팅 전략 수립이 용이해졌습니다. '새 회차 추가' 기능으로 재판매 프로세스가 매우 간소화되었습니다.

### 9. 메인 페이지 UI/UX 및 로직 개선

-   **문제점**: 상품 목록 페이지의 정보 표현이 부족하고, 레이아웃이 비정상적이거나 반복적인 오류가 발생하는 문제가 있었습니다.
-   **해결**:
    -   **상품 분류 로직 개선**: '오늘의 공동구매', '마감 임박! 추가 예약', '지난 공동구매'로 상품을 분류하는 로직이 업데이트되었습니다.

### 10. '섹션 헤더' 반응형 레이아웃 문제 해결 과정

-   **문제점**: 모바일과 같은 좁은 화면에서 섹션 제목(오늘의 공동구매)과 카운트다운 타이머가 한 줄에 표시될 때, 공간 부족으로 인해 제목이 잘리거나 레이아웃이 깨지는 문제가 발생했습니다.
-   **해결 과정**:
    -   처음에는 모바일에서 두 요소를 세로로 쌓는(`flex-direction: column`) 방식을 시도했으나, 디자인의 통일성을 해쳐 폐기했습니다.
    -   카운트다운을 공중에 띄우는(`position: absolute`) 방식도 시도했지만, 다른 요소와의 정렬 문제를 야기했습니다.
    -   **최종 해결책**: 모든 화면에서 한 줄 레이아웃을 유지하되, 모바일 화면에서는 미디어 쿼리를 사용해 제목과 카운트다운 모두의 글자 크기, 여백 등을 줄이는 방식을 채택했습니다. 이를 통해 공간을 확보하여, 잘림이나 줄바꿈 없이 두 요소가 조화롭게 표시되도록 개선했습니다.

### 11. '유령 여백' 디버깅 및 CSS 우선순위(Specificity) 문제 해결

-   **문제점**: 섹션 제목과 상품 카드 목록 사이에 원인을 알 수 없는 수직 여백('유령 여백')이 계속해서 남아, `margin`과 `padding`을 0으로 설정해도 문제가 해결되지 않았습니다.
-   **디버깅 과정**:
    -   브라우저 개발자 도구(F12)를 사용하여 문제의 원인을 추적했습니다.
    -   `border` 디버깅으로 여백의 위치를 특정했고, 요소 검사(Inspect)를 통해 여백이 `h2.section-title` 태그의 기본 `margin` 때문임을 확인했습니다.
    -   하지만 `ProductSection.css`에서 `margin: 0`을 적용해도 스타일이 바뀌지 않는 문제가 지속되었습니다.
-   **진짜 원인 및 해결책**:
    -   **원인**: `common.css` 파일에 정의된 전역 `.section-title` 스타일 규칙이, 컴포넌트별 CSS 파일인 `ProductSection.css`의 규칙보다 우선순위가 높거나 나중에 적용되어 스타일 변경을 덮어쓰고 있었습니다.
    -   **해결**: 특정 컴포넌트에서만 스타일을 억지로 덮어쓰는(`!important` 등`) 대신, 문제의 근원인 `common.css`의 전역 스타일 자체를 반응형으로 수정했습니다. 이를 통해 코드의 일관성을 유지하고, 예측 가능한 방식으로 문제를 해결했습니다. 또한, 이 과정에서 브라우저 캐시로 인해 스타일이 적용되지 않는 현상을 **'강력 새로고침'**으로 해결하는 방법도 확인했습니다.

### 12. 상세 페이지 안정성 및 하위 호환성 최종 개선

-   **문제점**:
    -   '추가 예약' 기간(마감일은 지났지만 픽업일은 도래하지 않은)에 있는 상품이 구매 불가능한 '판매 종료' 상태로 잘못 표시되는 버그가 있었습니다.
    -   과거 데이터 구조(판매 회차 `salesHistory`가 없는)를 가진 상품의 상세 페이지에 접근 시, 재고 확인 과정에서 `TypeError: Cannot read... 'find'` 오류가 발생하며 앱이 비정상적으로 종료되었습니다.
    -   옵션이 여러 개인 상품에서, 데이터베이스에 `id`가 없는 옵션이 포함된 경우 드롭다운 메뉴가 동작하지 않았습니다.

-   **원인**:
    -   **구매 가능 여부 판단 로직 오류**: '추가 예약' 기간을 올바르게 감지하는 조건문이 있었음에도, 최종적으로 구매 가능 상태를 결정하는 로직에 미세한 버그가 있어 '판매 종료'로 잘못 처리되었습니다.
    -   **서버-클라이언트 간 호환성 부재**: 프론트엔드(`ProductDetailPage`)는 구형 데이터를 신형으로 변환하는 로직이 있었지만, 서버 통신 함수(`checkProductAvailability`)는 이러한 변환 로직 없이 신규 데이터 구조(`salesHistory`)만 가정하고 호출되어 오류가 발생했습니다.
    -   **옵션 식별 방식의 한계**: 드롭다운 옵션 변경 로직이 데이터베이스의 `id` 값에만 의존하고 있어, 이 값이 없는 경우 어떤 옵션을 선택했는지 식별할 수 없었습니다.

-   **해결**:
    -   **구매 가능 여부 로직 수정**: 상세 페이지가 마운트될 때, 서버 재확인 전에 클라이언트에 있는 데이터를 기준으로 판매 기간(기본, 추가 예약 포함)과 재고를 먼저 판단하여 UI를 즉시 갱신하도록 로직을 수정하여 '추가 예약' 버그를 해결했습니다. 최종 구매 시점에는 서버를 통해 다시 한번 검증합니다.
    -   **백엔드 서비스 하위 호환성 확보**: `productService.ts`의 `checkProductAvailability` 함수를 수정하여, `salesHistory`의 존재 여부를 먼저 확인하고 데이터 구조에 따라 유연하게 재고를 확인할 수 있도록 개선했습니다. 이를 통해 구형 데이터 조회 시 발생하던 `TypeError`를 원천적으로 해결했습니다.
    -   **옵션 선택 로직 안정화**: 드롭다운 메뉴의 각 옵션을 식별하는 기준을 `id`가 아닌 **배열의 순서(index)**로 변경했습니다. 이를 통해 데이터베이스에 `id`가 누락된 경우에도 모든 옵션이 안정적으로 동작하도록 보장했습니다.
    -   **UX 추가 개선**:
        -   로딩 시 단순 스피너 대신 **스켈레톤 UI**를 표시하여 체감 성능을 향상시켰습니다.
        -   옵션 변경 시 **토스트 알림**으로 피드백을 주어 사용자가 선택을 명확히 인지하도록 했습니다.
        -   '앵콜 요청' 버튼은 **판매가 완전히 종료되거나 품절된 상품**에만 표시되도록 규칙을 명확히 하여 사용자 혼동을 줄였습니다.

### 13. 모달 닫기 후 스크롤 위치 초기화 문제 최종 해결 과정

-   **문제점**: 상품 상세 모달을 열었다 닫으면, 배경에 있던 목록 페이지의 스크롤 위치가 항상 최상단으로 초기화되어 사용자가 보던 위치를 잃어버리는 문제가 지속적으로 발생했습니다. 이로 인해 상단 배너가 헤더 뒤로 가려지는 등 심각한 UX 저하를 유발했습니다.

-   **시도했던 실패한 해결책들**:
    1.  **모달 라우팅**: 목록 페이지가 unmount되지 않도록 `location.state.background`를 사용했으나, 스크롤 문제 자체는 해결하지 못했습니다.
    2.  **수동 스크롤 복원**: `useRef`와 `useLayoutEffect`로 스크롤 위치를 저장하고 `window.scrollTo`로 복원하려 했으나, 브라우저의 렌더링 시점과 충돌하여 실패했습니다.
    3.  **스크롤 컨테이너 변경**: `body` 대신 별도의 `div`가 스크롤을 담당하도록 구조를 변경했지만, 문제의 근본 원인을 해결하지는 못했습니다.
    4.  **`createBrowserRouter` 도입**: React Router의 최신 데이터 라우터와 `<ScrollRestoration>`을 사용했으나, 오히려 다른 종류의 오류를 발생시켰습니다.

-   **진짜 원인 및 최종 해결책**:
    -   **원인**: 문제의 근본 원인은 **`position: fixed`로 고정된 헤더**와 **`body`의 `overflow`를 동적으로 변경하는 로직**의 조합이었습니다. 모달이 닫히면서 `body`의 스크롤바가 다시 나타나는 순간, 브라우저는 `fixed` 헤더를 기준으로 전체 문서의 높이를 재계산하는 과정에서 스크롤 위치를 잘못 판단하여 `0`으로 초기화시켰습니다.
    -   **해결 (구조적 접근)**:
        1.  **`position: sticky`로 헤더 변경**: 헤더의 CSS `position`을 `fixed`에서 **`sticky`**로 변경했습니다. `sticky` 속성은 헤더가 평소에는 문서 흐름 내에서 자신의 공간을 차지하다가, 스크롤될 때만 상단에 고정되므로 레이아웃 계산이 훨씬 안정적입니다. 이로 인해 불필요한 `padding-top`을 제거할 수 있었습니다.
        2.  **단순화된 스크롤 제어**: 안정적인 `sticky` 레이아웃을 기반으로, `CustomerLayout.tsx`에서 모달의 상태에 따라 **`body`의 `overflow`만 제어**하는 가장 단순한 `useLayoutEffect` 로직을 다시 적용했습니다. 레이아웃이 안정되니, 이 단순한 방법이 마침내 의도대로 정확하게 동작하여 스크롤 위치가 완벽하게 유지되었습니다.

### 14. 상품 등록/수정 페이지 UI/UX 최종 개편

-   **문제점**: 초기 상품 등록/수정 페이지는 정보 입력 필드가 여러 섹션에 분산되어 있어 스크롤이 길었고, 레이아웃이 고정되어 있어 화면 크기에 따른 유연성이 부족했습니다. 또한, 재고나 유통기한을 각 판매 옵션마다 입력해야 하는 등 비효율적이고 혼란을 유발하는 UI 요소들이 존재했습니다.
-   **최종 해결**: 사용자 피드백을 바탕으로 '직관, 간편, 쉬움'이라는 모토 아래 페이지 구조를 전면적으로 재설계했습니다.
    -   **반응형 3단 그리드 레이아웃 도입**: Flexbox를 활용하여, 화면 너비에 따라 섹션들이 3단 → 2단 → 1단으로 자동 재배치되는 유연한 레이아웃을 구현했습니다. 이를 통해 어떤 디바이스에서도 한눈에 정보를 파악할 수 있도록 사용성을 극대화했습니다.
    -   **정보 구조 재설계 및 통합**:
        -   **이미지 업로더 통합**: 별도 섹션을 차지하던 '대표 이미지'를 '대표 상품 정보' 카드 내부에 썸네일 형태의 컴팩트한 UI로 통합하여 공간 효율성을 높였습니다.
        -   **그룹 단위 유통기한 관리**: 각 옵션별로 중복 입력해야 했던 '유통기한'을 '하위 상품 그룹' 단위로 한 번만 입력하도록 변경하여 데이터 입력의 피로도를 줄이고 일관성을 확보했습니다.
    -   **UI 단순화 및 편의성 개선**:
        -   **재고 관리 직관성 향상**: '그룹 총 재고' 개념을 도입하고, 각 옵션에서는 '차감 단위'만 설정하도록 변경하여 재고 관리 로직을 명확하고 단순하게 만들었습니다.
        -   **버튼 통합**: '낱개/묶음 옵션 추가' 버튼을 '구매 옵션 추가' 버튼 하나로 통합하여 불필요한 선택 과정을 줄였습니다.
        -   **호버 툴팁 적용**: 레이아웃을 차지하던 아이콘 툴팁을 제거하고, 라벨에 마우스를 올리면 나타나는 방식으로 변경하여 화면을 더 깔끔하게 만들었습니다.

### 15. 수량 조절 버튼 동작 충돌 및 TypeError 해결
-   **문제점**: 수량 조절 버튼을 짧게 클릭 시 수량이 2씩 오르는 현상과, 특정 상황에서 `onClickRef.current is not a function`이라는 `TypeError`가 발생했습니다.
-   **원인**: 브라우저의 `onMouseUp`과 `onClick` 이벤트가 순차적으로 발생하며 로직이 중복 호출되었고, `useLongPress` 훅이 `onClick` 콜백 함수가 없는 경우를 대비하지 못해 `undefined`를 함수처럼 호출하려다 오류가 발생했습니다.
-   **해결**: `useLongPress` 훅의 로직을 전면 재설계했습니다. "꾹 누르기"가 발동되었는지 여부를 `useRef` 플래그로 추적하고, `onClick` 이벤트 핸들러는 이 플래그가 `false`일 때만("짧은 클릭"일 때만) 동작하도록 하여 두 이벤트의 충돌을 원천적으로 차단했습니다. 또한, 콜백 함수가 있는지 확인하는 방어 코드를 추가하여 `TypeError`를 해결하고 훅의 안정성을 높였습니다.

### 16. Firestore 트랜잭션 '읽기/쓰기 순서' 오류 해결
-   **문제점**: 주문 확정 시 `Firestore transactions require all reads to be executed before all writes` 오류가 발생하며 주문이 실패했습니다.
-   **원인**: `orderService.ts`의 `submitOrder` 함수 내에서, 쓰기 작업(`transaction.set`)이 발생한 이후에 다시 읽기 작업(`transaction.get`)을 수행하여 Firestore 트랜잭션의 "모든 읽기 작업 후 모든 쓰기 작업 수행" 규칙을 위반했습니다.
-   **해결**: 트랜잭션 로직을 읽기 단계와 쓰기 단계로 명확하게 분리했습니다. 트랜잭션 시작 시 필요한 모든 상품 문서를 미리 다 읽어서 변수에 저장해두고, 그 데이터를 바탕으로 재고 계산 및 분배를 마친 뒤, 마지막에 모든 쓰기(주문 생성, 대기 명단 업데이트) 작업을 순차적으로 수행하도록 구조를 변경하여 문제를 해결했습니다.

### 17. 모바일 반응형 레이아웃 깨짐 문제 해결
-   **문제점**: 일부 모바일 기기처럼 화면 너비가 좁은 환경에서 `CartPage`의 상품 카드 내부 요소들이 카드 밖으로 튀어나가는 등 레이아웃이 깨졌습니다.
-   **원인**: 고정된 `gap`과 `width` 값을 사용하는 Flexbox 레이아웃이 좁은 화면에 충분히 유연하게 대응하지 못했습니다.
-   **해결**: 미디어 쿼리를 사용해 레이아웃을 수직으로 쌓는 대신, Flexbox의 `flex-wrap: wrap` 속성을 활용하여 공간이 부족할 때 내부 요소(수량 조절 버튼, 가격 등)가 자연스럽게 아래로 줄바꿈되도록 수정했습니다. 또한, Flexbox의 자식 요소가 부모보다 작아질 수 있도록 `min-width: 0`을, 긴 텍스트가 레이아웃을 깨지 않도록 `text-overflow: ellipsis`를 적용하여 유연하고 깨지지 않는 반응형 디자인을 구현했습니다.

### 18. 상세 페이지 하단 고정 UI 렌더링 문제 최종 해결
-   **문제점**: 상품 상세 모달의 하단 구매 영역(수량 조절, 담기 버튼 등)이 화면에 보이지 않거나 다른 요소에 가려지는 문제가 반복적으로 발생했습니다. `position: fixed`와 `z-index`를 조정하는 방식으로는 근본적인 해결이 어려웠습니다.
-   **원인**: 문제의 근본 원인은 **CSS의 `position: fixed` 속성과 JSX의 구조적인 문제**였습니다. 하단 주문창을 `position: fixed`로 고정하면서, 스크롤되는 메인 컨텐츠와 분리된 별개의 레이어처럼 동작하게 되었습니다. 이로 인해 주문창이 다른 요소에 가려지거나, 의도치 않은 위치에 렌더링되어 보이지 않는 현상이 발생한 것입니다. 또한, 스크롤 영역을 담당하는 부모와 자식 요소에 `flex-grow: 1` 속성이 중첩되어 레이아웃 계산 충돌을 일으키기도 했습니다.
-   **해결 (구조적 접근)**: `position: fixed`를 사용하는 대신, **Flexbox 레이아웃만으로 UI를 전면 재구성**했습니다.
    1.  **JSX 구조 변경**: 모달 전체(`product-detail-modal-content`)를 flex 컨테이너로 만들고, 그 안에 **'스크롤 영역'(`.modal-scroll-area`)**과 **'하단 구매 영역'(`.product-purchase-footer`)**을 형제 요소로 배치하여 역할을 명확히 분리했습니다.
    2.  **CSS 수정**: 스크롤 영역에는 `flex-grow: 1`과 `overflow-y: auto`를 적용하여 남은 공간을 모두 차지하고 자체적으로 스크롤되도록 하고, 하단 구매 영역에는 `flex-shrink: 0`을 적용하여 크기가 줄어들지 않도록 했습니다. 레이아웃을 깨트리던 중복 `flex-grow` 속성은 제거했습니다.
    3.  **결과**: 이 구조적 변경을 통해 `z-index`나 `position` 속성에 의존하지 않고도, 하단 주문창이 항상 모달의 맨 아래에 안정적으로 고정되는 UI를 최종적으로 구현했습니다.

### 19. 전역 타입 시스템 안정화 및 타입 충돌 해결 과정

-   **문제점**: 프로젝트 곳곳에서 `Notification` (필요 속성 누락), `OrderItem` (필드 누락), `Order` (Timestamp와 FieldValue 혼용) 등 타입 정의가 다르거나 불완전하여 예측 불가능한 타입 오류가 지속적으로 발생했습니다. 이는 TypeScript의 강점을 제대로 활용하지 못하고 잠재적인 런타임 버그의 원인이 되었습니다.
-   **해결 과정**:
    -   **타입 정의 중앙화**: 모든 핵심 비즈니스 로직에 사용되는 타입을 `src/types.ts` 파일에서만 관리하는 **'단일 진실 공급원(Single Source of Truth)'** 원칙을 확립했습니다.
    -   **타입 통일 및 확장**:
        -   `Notification` 타입에 `read: boolean` 속성을 필수로 추가하여 `AuthContext`와 `Header` 컴포넌트 간의 타입 불일치를 해결했습니다.
        -   `OrderItem` 타입에 `category`, `subCategory`, `stock`, `arrivalDate`, `expirationDate`와 같은 필수 또는 선택적 필드들을 추가하여 `as any` 캐스팅 없이도 안전하게 데이터에 접근하도록 했습니다.
        -   `Order` 타입의 `createdAt` 필드가 `Timestamp | FieldValue`일 가능성을 명확히 하여 타입 오류를 방지했습니다.
    -   **개선 효과**: 코드 전반에서 `as any`와 같은 불필요한 타입 캐스팅을 제거하고 엄격한 타입 안정성을 확보했습니다. 이를 통해 개발 과정에서의 오류를 조기에 감지하고, 향후 발생할 수 있는 잠재적 런타임 버그를 원천적으로 차단하여 코드의 유지보수성과 견고성을 크게 향상시켰습니다.

### 20. 관리자 대시보드 기능 점진적 고도화

-   **문제점**: 초기 관리자 페이지에는 판매 현황을 한눈에 볼 수 있는 대시보드가 부재했으며, 재고를 공유하는 상품(예: 낱개/묶음)을 개별적으로 표시하여 재고 파악이 어렵고 관리 효율이 떨어졌습니다.
-   **개선 과정**: 사용자(관리자)의 실제 업무 흐름에 맞춰 다음과 같이 점진적으로 기능을 고도화했습니다.
    1.  **초기 기획**: '판매 중인 상품'과 '발주 완료된 상품'을 두 개의 섹션으로 나누는 초기 아이디어를 구상했습니다.
    2.  **핵심 문제 인식 및 방향 전환**: 여러 옵션이 하나의 재고를 공유하는 비즈니스 로직을 정확히 반영하는 것이 더 중요하다는 것을 파악하고, **'하위 상품 그룹(`VariantGroup`)'을 하나의 단위로 묶어 표시**하는 현재의 '통합 대시보드' 방식으로 방향을 전면 수정했습니다.
    3.  **데이터 표시 로직 개선**: '설정된 재고'를 표시할 때, 그룹 전체의 공유 재고(`totalPhysicalStock`)를 우선적으로 보여주되, 이 값이 설정되지 않은 경우에는 그룹 내 첫 번째 옵션의 개별 재고(`item.stock`)를 대신 표시하도록 로직을 개선하여 데이터가 누락되어 보이는 문제를 해결했습니다.
-   **개선 효과**: 단순 목록 표시에 그치지 않고, 복잡한 재고 공유 로직을 정확하게 반영하는 비즈니스 인텔리전스 도구로 발전했습니다. 이를 통해 관리자는 실제 재고 현황을 직관적으로 파악하고, 1차 마감 후 발주 및 2차 판매로 이어지는 핵심 워크플로우를 효율적으로 관리할 수 있게 되었습니다.

### 21. 장바구니 페이지 훅(Hook) 규칙 위반 오류 해결

* **문제점**: 장바구니 페이지(`CartPage.tsx`)에서 수량 조절 버튼을 길게 누르는 기능을 구현하기 위해 `useLongPress` 커스텀 훅을 사용했으나, "Rendered fewer hooks than expected" 오류가 발생하며 앱이 중단되는 문제가 있었습니다.
* **원인**: `useLongPress` 훅이 컴포넌트의 최상위 레벨이 아닌, 반복문(`.map`) 내부의 일반 함수 안에서 조건부로 호출되어 React의 훅 규칙을 위반했습니다.
* **해결**:
    * **컴포넌트 분리**: 문제가 된 상품 카드 UI와 로직을 별도의 `CartItemCard` 컴포넌트로 분리했습니다.
    * **안전한 훅 호출**: 분리된 `CartItemCard` 컴포넌트의 최상위 레벨에서 `useLongPress` 훅을 호출하도록 구조를 변경하여, 훅의 규칙을 준수하고 오류를 근본적으로 해결했습니다. 이 리팩터링을 통해 코드의 재사용성과 가독성도 함께 향상시켰습니다.

### 22. 카테고리 관리 기능의 구조적 분리 및 재설계

* **문제점**: 초기 카테고리 관리 페이지는 카테고리의 구조(생성, 수정)를 정의하는 기능과 상품에 카테고리를 '지정'하는 기능이 혼재되어 있어 역할이 불분명하고 확장성이 떨어졌습니다.
* **해결**: 사용자(관리자)의 작업 흐름에 맞춰 두 페이지의 역할을 명확하게 분리하고 재설계했습니다.
    1.  **카테고리 '구조' 관리 (`CategoryManagementPage.tsx`)**: 이 페이지는 이제 대분류 카테고리를 생성, 수정, 삭제하고 순서를 정하는 **'폴더 관리'** 역할에만 집중합니다. 복잡성을 유발하던 하위 카테고리 기능은 제거하여 시스템을 단순화했습니다.
    2.  **상품 카테고리 '지정' (`ProductCategoryBatchPage.tsx`)**: POS 시스템과 유사한 2단 레이아웃의 새로운 페이지를 만들어, 상품을 특정 카테고리로 **'분류하는 작업'**을 전담하도록 했습니다. 관리자는 드래그 앤 드롭으로 상품을 원하는 카테고리에 던져넣는 직관적인 방식으로 작업을 수행할 수 있습니다.
* **기대 효과**: 각 페이지의 역할과 책임이 명확해져 유지보수가 용이해졌으며, 관리자는 훨씬 효율적이고 직관적인 UI를 통해 상품을 관리할 수 있게 되었습니다.

### 23. 장바구니 대기 상품 자동화 및 UI 고도화

* **문제점**: 기존 장바구니는 품절 상품에 대한 '대기' 신청만 가능했을 뿐, 이후 재고가 확보되어도 사용자가 직접 다시 구매해야 하는 불편함이 있었습니다. 또한 데스크탑 환경에서의 UI가 비효율적이었습니다.
* **해결**:
    * **대기 상품 자동 처리 로직 도입**: 장바구니 페이지 진입 시, '대기' 상태인 상품의 실시간 재고를 자동으로 확인합니다. 재고가 확보되면 해당 상품을 '예약' 상태로 자동 전환하고, 픽업 기한이 지난 상품은 목록에서 자동 삭제하는 기능을 `CartPage.tsx`와 `productService.ts`에 구현했습니다.
    * **데스크탑 레이아웃 최적화**: 넓은 화면에서는 왼쪽에는 상품 목록, 오른쪽에는 주문 요약 정보가 표시되는 **2단 그리드 레이아웃**을 적용하여 전문성을 높였습니다.
    * **재고 초과 방지**: 상품 수량을 늘릴 때, 구매 가능한 재고 이상으로 수량을 늘릴 수 없도록 '+' 버튼을 비활성화하고 토스트 알림으로 피드백을 주는 기능을 추가했습니다.
* **개선 효과**: 사용자는 재고 변동을 신경 쓸 필요 없이 자동으로 예약을 확정받을 수 있게 되었고, 관리자는 수동 안내의 부담을 덜게 되었습니다. 데스크탑 UI 개선으로 사용 편의성 또한 크게 향상되었습니다.

## 🚀 앞으로의 개선 방향

현재의 튼튼한 기반 위에서 프로젝트를 한 단계 더 높은 수준으로 발전시키기 위한 다음 단계 제안입니다.

### 1. 성능 최적화: "더 빠르고 쾌적한 사용자 경험" (페이지네이션)

-   **문제점**: 현재는 메인 페이지 진입 시 모든 상품 데이터를 한 번에 불러오기 때문에, 상품 수가 많아지면 초기 로딩 속도가 느려질 수 있습니다.
-   **개선 방향**: `getProducts` 함수에 **페이지네이션(Pagination)** 또는 **무한 스크롤** 기능을 도입합니다. Firebase의 `limit()`과 `startAfter()` 쿼리 함수를 사용하여, 사용자가 스크롤을 내릴 때마다 다음 상품 목록을 순차적으로 불러오는 방식입니다. 이를 통해 초기 로딩 시간을 비약적으로 단축하고 사용자 경험을 향상시킬 수 있습니다.

### 2. 테스트 코드 작성: "미래의 버그를 예방하는 보험"

-   **문제점**: 현재 프로젝트에는 자동화된 테스트 코드가 없어, 새로운 기능 추가나 코드 수정 시 의도치 않은 버그가 발생할 위험이 있습니다.
-   **개선 방향**: **Vitest**와 **React Testing Library**를 도입하여 테스트 코드를 작성합니다.
    -   **유닛 테스트**: `productService`의 함수들이 정확한 값을 반환하는지, 가격 계산 로직이 올바른지 등을 테스트합니다.
    -   **컴포넌트 테스트**: `ProductCard`가 주어진 데이터에 따라 올바른 UI를 렌더링하는지 테스트합니다.
    -   **기대 효과**: 코드 변경에 대한 자신감을 높이고, 장기적으로 훨씬 안정적인 서비스를 운영할 수 있습니다.

### 3. UI/UX 일관성 확보: "체계적인 디자인 시스템 구축"

-   **문제점**: 프로젝트가 커질수록 버튼, 입력창, 색상 등의 디자인이 페이지마다 미세하게 달라져 통일성을 잃기 쉽습니다.
-   **개선 방향**: **Storybook** 같은 도구를 사용하여 재사용 가능한 UI 컴포넌트들을 모아놓은 독립적인 **디자인 시스템**을 구축합니다.
    -   **방법**: `Button`, `Input`, `Modal` 등 가장 기본적인 UI 요소부터 컴포넌트로 만들어 Storybook에서 시각적으로 확인하고 테스트합니다.
    -   **기대 효과**: 어떤 페이지에서든 항상 동일한 디자인의 UI를 사용하여 일관된 사용자 경험을 제공하고, 이미 만들어진 부품을 조립하듯 새로운 페이지를 매우 빠르게 개발할 수 있습니다.